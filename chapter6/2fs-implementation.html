<!doctype html>
<html class="no-js" lang="zh_CN">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><link rel="index" title="索引" href="../genindex.html" /><link rel="search" title="搜索" href="../search.html" /><link rel="next" title="在内核中接入 easy-fs" href="3using-easy-fs-in-kernel.html" /><link rel="prev" title="文件系统接口" href="1fs-interface.html" />

    <meta name="generator" content="sphinx-4.3.2, furo 2022.06.21"/>
        <title>简易文件系统 easy-fs - rCore-Tutorial-Book-v3 3.6.0-alpha.1 文档</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?digest=40978830699223671f4072448e654b5958f38b89" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    <link rel="stylesheet" type="text/css" href="../_static/my_style.css" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">rCore-Tutorial-Book-v3 3.6.0-alpha.1 文档</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../index.html">
  
  
  <span class="sidebar-brand-text">rCore-Tutorial-Book-v3 3.6.0-alpha.1 文档</span>
  
</a><form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder=搜索 name="q" aria-label="搜索">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Part1 - Just do it!</span></p>
<ul class="current">
<li class="toctree-l1 has-children"><a class="reference internal" href="../chapter0/index.html">第零章：操作系统概述</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter0/0intro.html">引言</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../chapter0/1what-is-os.html">什么是操作系统</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="simple">
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../chapter0/2os-interface.html">操作系统的系统调用接口</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="simple">
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../chapter0/3os-hw-abstract.html">操作系统抽象</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" role="switch" type="checkbox"/><label for="toctree-checkbox-4"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="simple">
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../chapter0/4os-features.html">操作系统的特征</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" role="switch" type="checkbox"/><label for="toctree-checkbox-5"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="simple">
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../chapter0/5setup-devel-env.html">实验环境配置</a><input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" role="switch" type="checkbox"/><label for="toctree-checkbox-6"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="simple">
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../chapter0/7exercise.html">练习</a><input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" role="switch" type="checkbox"/><label for="toctree-checkbox-7"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="simple">
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../chapter0/8answer.html">练习参考答案</a><input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" role="switch" type="checkbox"/><label for="toctree-checkbox-8"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="simple">
</ul>
</li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../chapter1/index.html">第一章：应用程序与基本执行环境</a><input class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" role="switch" type="checkbox"/><label for="toctree-checkbox-9"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter1/0intro.html">引言</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../chapter1/1app-ee-platform.html">应用程序执行环境与平台支持</a><input class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" role="switch" type="checkbox"/><label for="toctree-checkbox-10"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="simple">
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../chapter1/2remove-std.html">移除标准库依赖</a><input class="toctree-checkbox" id="toctree-checkbox-11" name="toctree-checkbox-11" role="switch" type="checkbox"/><label for="toctree-checkbox-11"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="simple">
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../chapter1/3first-instruction-in-kernel1.html">内核第一条指令（基础篇）</a><input class="toctree-checkbox" id="toctree-checkbox-12" name="toctree-checkbox-12" role="switch" type="checkbox"/><label for="toctree-checkbox-12"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="simple">
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../chapter1/4first-instruction-in-kernel2.html">内核第一条指令（实践篇）</a><input class="toctree-checkbox" id="toctree-checkbox-13" name="toctree-checkbox-13" role="switch" type="checkbox"/><label for="toctree-checkbox-13"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="simple">
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../chapter1/5support-func-call.html">为内核支持函数调用</a><input class="toctree-checkbox" id="toctree-checkbox-14" name="toctree-checkbox-14" role="switch" type="checkbox"/><label for="toctree-checkbox-14"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="simple">
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../chapter1/6print-and-shutdown-based-on-sbi.html">基于 SBI 服务完成输出和关机</a><input class="toctree-checkbox" id="toctree-checkbox-15" name="toctree-checkbox-15" role="switch" type="checkbox"/><label for="toctree-checkbox-15"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="simple">
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../chapter1/7exercise.html">练习</a><input class="toctree-checkbox" id="toctree-checkbox-16" name="toctree-checkbox-16" role="switch" type="checkbox"/><label for="toctree-checkbox-16"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="simple">
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../chapter1/8answer.html">练习参考答案</a><input class="toctree-checkbox" id="toctree-checkbox-17" name="toctree-checkbox-17" role="switch" type="checkbox"/><label for="toctree-checkbox-17"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="simple">
</ul>
</li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../chapter2/index.html">第二章：批处理系统</a><input class="toctree-checkbox" id="toctree-checkbox-18" name="toctree-checkbox-18" role="switch" type="checkbox"/><label for="toctree-checkbox-18"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter2/0intro.html">引言</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../chapter2/1rv-privilege.html">特权级机制</a><input class="toctree-checkbox" id="toctree-checkbox-19" name="toctree-checkbox-19" role="switch" type="checkbox"/><label for="toctree-checkbox-19"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="simple">
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../chapter2/2application.html">实现应用程序</a><input class="toctree-checkbox" id="toctree-checkbox-20" name="toctree-checkbox-20" role="switch" type="checkbox"/><label for="toctree-checkbox-20"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="simple">
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../chapter2/3batch-system.html">实现批处理操作系统</a><input class="toctree-checkbox" id="toctree-checkbox-21" name="toctree-checkbox-21" role="switch" type="checkbox"/><label for="toctree-checkbox-21"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="simple">
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../chapter2/4trap-handling.html">实现特权级的切换</a><input class="toctree-checkbox" id="toctree-checkbox-22" name="toctree-checkbox-22" role="switch" type="checkbox"/><label for="toctree-checkbox-22"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="simple">
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../chapter2/5exercise.html">练习</a><input class="toctree-checkbox" id="toctree-checkbox-23" name="toctree-checkbox-23" role="switch" type="checkbox"/><label for="toctree-checkbox-23"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="simple">
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../chapter2/6answer.html">练习参考答案</a><input class="toctree-checkbox" id="toctree-checkbox-24" name="toctree-checkbox-24" role="switch" type="checkbox"/><label for="toctree-checkbox-24"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="simple">
</ul>
</li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../chapter3/index.html">第三章：多道程序与分时多任务</a><input class="toctree-checkbox" id="toctree-checkbox-25" name="toctree-checkbox-25" role="switch" type="checkbox"/><label for="toctree-checkbox-25"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter3/0intro.html">引言</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter3/1multi-loader.html">多道程序放置与加载</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter3/2task-switching.html">任务切换</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter3/3multiprogramming.html">多道程序与协作式调度</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter3/4time-sharing-system.html">分时多任务系统与抢占式调度</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter3/5exercise.html">练习</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter3/6answer.html">练习参考答案</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../chapter4/index.html">第四章：地址空间</a><input class="toctree-checkbox" id="toctree-checkbox-26" name="toctree-checkbox-26" role="switch" type="checkbox"/><label for="toctree-checkbox-26"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter4/0intro.html">引言</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter4/1rust-dynamic-allocation.html">Rust 中的动态内存分配</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter4/2address-space.html">地址空间</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter4/3sv39-implementation-1.html">SV39 多级页表的硬件机制</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter4/4sv39-implementation-2.html">管理 SV39 多级页表</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter4/5kernel-app-spaces.html">内核与应用的地址空间</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter4/6multitasking-based-on-as.html">基于地址空间的分时多任务</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter4/7more-as.html">超越物理内存的地址空间</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter4/8exercise.html">练习</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter4/9answer.html">练习参考答案</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../chapter5/index.html">第五章：进程</a><input class="toctree-checkbox" id="toctree-checkbox-27" name="toctree-checkbox-27" role="switch" type="checkbox"/><label for="toctree-checkbox-27"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter5/0intro.html">引言</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter5/1process.html">进程概念及重要系统调用</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter5/2core-data-structures.html">进程管理的核心数据结构</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter5/3implement-process-mechanism.html">进程管理机制的设计实现</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter5/4scheduling.html">进程调度</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter5/5exercise.html">练习</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter5/6answer.html">练习参考答案</a></li>
</ul>
</li>
<li class="toctree-l1 current has-children"><a class="reference internal" href="index.html">第六章：文件系统</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-28" name="toctree-checkbox-28" role="switch" type="checkbox"/><label for="toctree-checkbox-28"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="0intro.html">引言</a></li>
<li class="toctree-l2"><a class="reference internal" href="1fs-interface.html">文件系统接口</a></li>
<li class="toctree-l2 current current-page"><a class="current reference internal" href="#">简易文件系统 easy-fs</a></li>
<li class="toctree-l2"><a class="reference internal" href="3using-easy-fs-in-kernel.html">在内核中接入 easy-fs</a></li>
<li class="toctree-l2"><a class="reference internal" href="4exercise.html">练习</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="5answer.html">练习参考答案</a><input class="toctree-checkbox" id="toctree-checkbox-29" name="toctree-checkbox-29" role="switch" type="checkbox"/><label for="toctree-checkbox-29"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="simple">
</ul>
</li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../chapter7/index.html">第七章：进程间通信与 I/O 重定向</a><input class="toctree-checkbox" id="toctree-checkbox-30" name="toctree-checkbox-30" role="switch" type="checkbox"/><label for="toctree-checkbox-30"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter7/0intro.html">引言</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter7/1file-descriptor.html">基于文件的标准输入/输出</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter7/2pipe.html">管道</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter7/3cmdargs-and-redirection.html">命令行参数与标准 I/O 重定向</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter7/4signal.html">信号</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter7/5exercise.html">练习</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../chapter7/6answer.html">练习参考答案</a><input class="toctree-checkbox" id="toctree-checkbox-31" name="toctree-checkbox-31" role="switch" type="checkbox"/><label for="toctree-checkbox-31"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="simple">
</ul>
</li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../chapter8/index.html">第八章：并发</a><input class="toctree-checkbox" id="toctree-checkbox-32" name="toctree-checkbox-32" role="switch" type="checkbox"/><label for="toctree-checkbox-32"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter8/0intro.html">引言</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter8/1thread.html">用户态的线程管理</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter8/1thread-kernel.html">内核态的线程管理</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter8/2lock.html">互斥锁</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter8/3semaphore.html">信号量机制</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter8/4condition-variable.html">条件变量机制</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter8/5concurrency-problem.html">并发中的问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter8/6exercise.html">练习</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../chapter8/7answer.html">练习参考答案</a><input class="toctree-checkbox" id="toctree-checkbox-33" name="toctree-checkbox-33" role="switch" type="checkbox"/><label for="toctree-checkbox-33"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="simple">
</ul>
</li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../chapter9/index.html">第九章：I/O设备管理</a><input class="toctree-checkbox" id="toctree-checkbox-34" name="toctree-checkbox-34" role="switch" type="checkbox"/><label for="toctree-checkbox-34"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../chapter9/0intro.html">引言</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter9/1io-interface.html">I/O设备</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter9/2device-driver-0.html">外设平台</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter9/2device-driver-1.html">串口驱动程序</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter9/2device-driver-2.html">virtio设备驱动程序</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter9/2device-driver-3.html">virtio_blk块设备驱动程序</a></li>
<li class="toctree-l2"><a class="reference internal" href="../chapter9/2device-driver-4.html">virtio_gpu设备驱动程序</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../chapter9/4exercise.html">练习</a><input class="toctree-checkbox" id="toctree-checkbox-35" name="toctree-checkbox-35" role="switch" type="checkbox"/><label for="toctree-checkbox-35"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="simple">
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../chapter9/5answer.html">练习参考答案</a><input class="toctree-checkbox" id="toctree-checkbox-36" name="toctree-checkbox-36" role="switch" type="checkbox"/><label for="toctree-checkbox-36"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="simple">
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">附录</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../final-lab.html">综合练习</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../appendix-a/index.html">附录 A：Rust 系统编程入门</a><input class="toctree-checkbox" id="toctree-checkbox-37" name="toctree-checkbox-37" role="switch" type="checkbox"/><label for="toctree-checkbox-37"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="simple">
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../appendix-b/index.html">附录 B：常见工具的使用方法</a><input class="toctree-checkbox" id="toctree-checkbox-38" name="toctree-checkbox-38" role="switch" type="checkbox"/><label for="toctree-checkbox-38"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="simple">
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../appendix-c/index.html">附录 C：深入机器模式：RustSBI</a><input class="toctree-checkbox" id="toctree-checkbox-39" name="toctree-checkbox-39" role="switch" type="checkbox"/><label for="toctree-checkbox-39"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="simple">
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../appendix-d/index.html">附录 D：RISC-V相关信息</a><input class="toctree-checkbox" id="toctree-checkbox-40" name="toctree-checkbox-40" role="switch" type="checkbox"/><label for="toctree-checkbox-40"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../appendix-d/1asm.html">RISCV 汇编相关</a></li>
<li class="toctree-l2"><a class="reference internal" href="../appendix-d/2rv.html">RISCV 硬件相关</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../appendix-e/index.html">附录 E：操作系统进一步介绍</a><input class="toctree-checkbox" id="toctree-checkbox-41" name="toctree-checkbox-41" role="switch" type="checkbox"/><label for="toctree-checkbox-41"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="simple">
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../appendix-f/index.html">附录 F：类 Peterson 算法的局限性和内存顺序</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../terminology.html">术语中英文对照表</a><input class="toctree-checkbox" id="toctree-checkbox-42" name="toctree-checkbox-42" role="switch" type="checkbox"/><label for="toctree-checkbox-42"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="simple">
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">开发注记</span></p>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../setup-sphinx.html">修改和构建本项目</a><input class="toctree-checkbox" id="toctree-checkbox-43" name="toctree-checkbox-43" role="switch" type="checkbox"/><label for="toctree-checkbox-43"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="simple">
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../rest-example.html">reStructuredText 基本语法</a><input class="toctree-checkbox" id="toctree-checkbox-44" name="toctree-checkbox-44" role="switch" type="checkbox"/><label for="toctree-checkbox-44"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="simple">
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../log.html">更新日志</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <div class="section" id="easy-fs">
<h1>简易文件系统 easy-fs<a class="headerlink" href="#easy-fs" title="永久链接至标题">#</a></h1>
<div class="section" id="id1">
<h2>本节导读<a class="headerlink" href="#id1" title="永久链接至标题">#</a></h2>
<p>本节我们介绍一个简易文件系统的实现 – easy-fs。作为一个文件系统而言，它的磁盘布局（为了叙述方便，我们用磁盘来指代一系列持久存储设备）体现在磁盘上各扇区的内容上，而它解析磁盘布局得到的逻辑目录树结构则是通过内存上的数据结构来访问的，这意味着它要同时涉及到对磁盘和对内存的访问。它们的访问方式是不同的，对于内存直接通过一条指令即可直接读写内存相应的位置，而磁盘的话需要用软件的方式向磁盘发出请求来间接进行读写。因此，我们也要特别注意哪些数据结构是存储在磁盘上，哪些数据结构是存储在内存中的，这样在实现的时候才不会引起混乱。</p>
</div>
<div class="section" id="id2">
<h2>松耦合模块化设计思路<a class="headerlink" href="#id2" title="永久链接至标题">#</a></h2>
<p>大家可以看到，本章的内核功能越来越多，代码量也越来越大（但仅仅是Linux代码量的万分之一左右）。为了减少同学学习内核的分析理解成本，我们需要让内核的各个部分之间尽量松耦合，所以easy-fs 被从内核中分离出来，它的实现分成两个不同的 crate ：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">easy-fs</span></code> 为简易文件系统的核心部分，它是一个库形式 crate，实现一种简单的文件系统磁盘布局；</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">easy-fs-fuse</span></code> 是一个能在开发环境（如 Ubuntu）中运行的应用程序，它可以对 <code class="docutils literal notranslate"><span class="pre">easy-fs</span></code> 进行测试，或者将为我们内核开发的应用打包为一个 easy-fs 格式的文件系统镜像。</p></li>
</ul>
<p>这样，整个easy-fs文件系统的设计开发可以按照应用程序库的开发过程来完成。而且在开发完毕后，可直接放到内核中，形成有文件系统支持的新内核。</p>
<p>能做到这一点，是由于我们在easy-fs设计上，采用了松耦合模块化设计思路。easy-fs与底层设备驱动之间通过抽象接口 <code class="docutils literal notranslate"><span class="pre">BlockDevice</span></code> 来连接，避免了与设备驱动的绑定。easy-fs通过Rust提供的alloc crate来隔离了操作系统内核的内存管理，避免了直接调用内存管理的内核函数。在底层驱动上，采用的是轮询的方式访问 <code class="docutils literal notranslate"><span class="pre">virtio_blk</span></code> 虚拟磁盘设备，从而避免了访问外设中断的相关内核函数。easy-fs在设计中避免了直接访问进程相关的数据和函数，从而隔离了操作系统内核的进程管理。</p>
<p>同时，easy-fs本身也划分成不同的层次，形成层次化和模块化的设计架构。<code class="docutils literal notranslate"><span class="pre">easy-fs</span></code> crate 自下而上大致可以分成五个不同的层次：</p>
<ol class="arabic simple">
<li><p>磁盘块设备接口层：定义了以块大小为单位对磁盘块设备进行读写的trait接口</p></li>
<li><p>块缓存层：在内存中缓存磁盘块的数据，避免频繁读写磁盘</p></li>
<li><p>磁盘数据结构层：磁盘上的超级块、位图、索引节点、数据块、目录项等核心数据结构和相关处理</p></li>
<li><p>磁盘块管理器层：合并了上述核心数据结构和磁盘布局所形成的磁盘文件系统数据结构，以及基于这些结构的创建/打开文件系统的相关处理和磁盘块的分配和回收处理</p></li>
<li><p>索引节点层：管理索引节点（即文件控制块）数据结构，并实现文件创建/文件打开/文件读写等成员函数来向上支持文件操作相关的系统调用</p></li>
</ol>
<p>大家也许觉得有五层架构的文件系统是一个很复杂的软件。其实，相对于面向Qemu模拟器的操作系统内核源码所占的2400行左右代码，它只有900行左右的代码，占总代码量的27%。且由于其代码逻辑其实是一种自下而上的线性思维，属于传统的常规编程。相对于异常/中断/系统调用的特权级切换，进程管理中的进程上下文切换，内存管理中的页表地址映射等涉及异常控制流和硬件访问的非常规编程，文件系统的设计实现其实更容易理解。</p>
</div>
<div class="section" id="id3">
<h2>块设备接口层<a class="headerlink" href="#id3" title="永久链接至标题">#</a></h2>
<p>定义设备驱动需要实现的块读写接口 <code class="docutils literal notranslate"><span class="pre">BlockDevice</span></code> trait的块设备接口层代码在 <code class="docutils literal notranslate"><span class="pre">block_dev.rs</span></code> 中。</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">easy-fs</span></code> 库的最底层声明了一个块设备的抽象接口 <code class="docutils literal notranslate"><span class="pre">BlockDevice</span></code> ：</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// easy-fs/src/block_dev.rs</span>

<span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">BlockDevice</span><span class="w"> </span>: <span class="nb">Send</span> <span class="o">+</span><span class="w"> </span><span class="nb">Sync</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Any</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">read_block</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">block_id</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">]);</span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">write_block</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">block_id</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">]);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>它需要实现两个抽象方法：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">read_block</span></code> 将编号为 <code class="docutils literal notranslate"><span class="pre">block_id</span></code> 的块从磁盘读入内存中的缓冲区 <code class="docutils literal notranslate"><span class="pre">buf</span></code> ；</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">write_block</span></code> 将内存中的缓冲区 <code class="docutils literal notranslate"><span class="pre">buf</span></code> 中的数据写入磁盘编号为 <code class="docutils literal notranslate"><span class="pre">block_id</span></code> 的块。</p></li>
</ul>
<p>在 <code class="docutils literal notranslate"><span class="pre">easy-fs</span></code> 中并没有一个实现了 <code class="docutils literal notranslate"><span class="pre">BlockDevice</span></code> Trait 的具体类型。因为块设备仅支持以块为单位进行随机读写，所以需要由具体的块设备驱动来实现这两个方法，实际上这是需要由文件系统的使用者（比如操作系统内核或直接测试 <code class="docutils literal notranslate"><span class="pre">easy-fs</span></code> 文件系统的 <code class="docutils literal notranslate"><span class="pre">easy-fs-fuse</span></code> 应用程序）提供并接入到 <code class="docutils literal notranslate"><span class="pre">easy-fs</span></code> 库的。 <code class="docutils literal notranslate"><span class="pre">easy-fs</span></code> 库的块缓存层会调用这两个方法，进行块缓存的管理。这也体现了 <code class="docutils literal notranslate"><span class="pre">easy-fs</span></code> 的泛用性：它可以访问实现了 <code class="docutils literal notranslate"><span class="pre">BlockDevice</span></code> Trait 的块设备驱动程序。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p><strong>块与扇区</strong></p>
<p>实际上，块和扇区是两个不同的概念。 <strong>扇区</strong> (Sector) 是块设备随机读写的数据单位，通常每个扇区为 512 字节。而块是文件系统存储文件时的数据单位，每个块的大小等同于一个或多个扇区。之前提到过 Linux 的Ext4文件系统的单个块大小默认为 4096 字节。在我们的 easy-fs 实现中一个块和一个扇区同为 512 字节，因此在后面的讲解中我们不再区分扇区和块的概念。</p>
</div>
</div>
<div class="section" id="id4">
<h2>块缓存层<a class="headerlink" href="#id4" title="永久链接至标题">#</a></h2>
<p>实现磁盘块缓存功能的块缓存层的代码在 <code class="docutils literal notranslate"><span class="pre">block_cache.rs</span></code> 中。</p>
<p>由于操作系统频繁读写速度缓慢的磁盘块会极大降低系统性能，因此常见的手段是先通过 <code class="docutils literal notranslate"><span class="pre">read_block</span></code> 将一个块上的数据从磁盘读到内存中的一个缓冲区中，这个缓冲区中的内容是可以直接读写的，那么后续对这个数据块的大部分访问就可以在内存中完成了。如果缓冲区中的内容被修改了，那么后续还需要通过 <code class="docutils literal notranslate"><span class="pre">write_block</span></code> 将缓冲区中的内容写回到磁盘块中。</p>
<p>事实上，无论站在代码实现鲁棒性还是性能的角度，将这些缓冲区合理的管理起来都是很有必要的。一种完全不进行任何管理的模式可能是：每当要对一个磁盘块进行读写的时候，都通过 <code class="docutils literal notranslate"><span class="pre">read_block</span></code> 将块数据读取到一个 <em>临时</em> 创建的缓冲区，并在进行一些操作之后（可选地）将缓冲区的内容写回到磁盘块。从性能上考虑，我们需要尽可能降低实际块读写（即 <code class="docutils literal notranslate"><span class="pre">read/write_block</span></code> ）的次数，因为每一次调用它们都会产生大量开销。要做到这一点，关键就在于对块读写操作进行 <strong>合并</strong> 。例如，如果一个块已经被读到缓冲区中了，那么我们就没有必要再读一遍，直接用已有的缓冲区就行了；同时，对于缓冲区中的同一个块的多次修改没有必要每次都写回磁盘，只需等所有的修改都结束之后统一写回磁盘即可。</p>
<p>当磁盘上的数据结构比较复杂的时候，很难通过应用来合理地规划块读取/写入的时机。这不仅可能涉及到复杂的参数传递，稍有不慎还有可能引入同步性问题(目前可以暂时忽略)：即一个块缓冲区修改后的内容在后续的同一个块读操作中不可见，这很致命但又难以调试。</p>
<p>因此，我们的做法是将缓冲区统一管理起来。当我们要读写一个块的时候，首先就是去全局管理器中查看这个块是否已被缓存到内存缓冲区中。如果是这样，则在一段连续时间内对于一个块进行的所有操作均是在同一个固定的缓冲区中进行的，这解决了同步性问题。此外，通过 <code class="docutils literal notranslate"><span class="pre">read/write_block</span></code> 进行块实际读写的时机完全交给块缓存层的全局管理器处理，上层子系统无需操心。全局管理器会尽可能将更多的块操作合并起来，并在必要的时机发起真正的块实际读写。</p>
<div class="section" id="id5">
<h3>块缓存<a class="headerlink" href="#id5" title="永久链接至标题">#</a></h3>
<p>块缓存 <code class="docutils literal notranslate"><span class="pre">BlockCache</span></code> 的定义如下：</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// easy-fs/src/lib.rs</span>

<span class="k">pub</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">BLOCK_SZ</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="mi">512</span><span class="p">;</span>

<span class="c1">// easy-fs/src/block_cache.rs</span>

<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">BlockCache</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">cache</span>: <span class="p">[</span><span class="kt">u8</span><span class="p">;</span><span class="w"> </span><span class="n">BLOCK_SZ</span><span class="p">],</span>
<span class="w">    </span><span class="n">block_id</span>: <span class="kt">usize</span><span class="p">,</span>
<span class="w">    </span><span class="n">block_device</span>: <span class="nc">Arc</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">BlockDevice</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">    </span><span class="n">modified</span>: <span class="kt">bool</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>
</div>
<p>其中：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">cache</span></code> 是一个 512 字节的数组，表示位于内存中的缓冲区；</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">block_id</span></code> 记录了这个块缓存来自于磁盘中的块的编号；</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">block_device</span></code> 是一个底层块设备的引用，可通过它进行块读写；</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">modified</span></code> 记录这个块从磁盘载入内存缓存之后，它有没有被修改过。</p></li>
</ul>
<p>当我们创建一个 <code class="docutils literal notranslate"><span class="pre">BlockCache</span></code> 的时候，这将触发一次 <code class="docutils literal notranslate"><span class="pre">read_block</span></code> 将一个块上的数据从磁盘读到缓冲区 <code class="docutils literal notranslate"><span class="pre">cache</span></code> ：</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// easy-fs/src/block_cache.rs</span>

<span class="k">impl</span><span class="w"> </span><span class="n">BlockCache</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="sd">/// Load a new BlockCache from disk.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span>
<span class="w">        </span><span class="n">block_id</span>: <span class="kt">usize</span><span class="p">,</span>
<span class="w">        </span><span class="n">block_device</span>: <span class="nc">Arc</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">BlockDevice</span><span class="o">&gt;</span>
<span class="w">    </span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">cache</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="k">u8</span><span class="p">;</span><span class="w"> </span><span class="n">BLOCK_SZ</span><span class="p">];</span>
<span class="w">        </span><span class="n">block_device</span><span class="p">.</span><span class="n">read_block</span><span class="p">(</span><span class="n">block_id</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">cache</span><span class="p">);</span>
<span class="w">        </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">cache</span><span class="p">,</span>
<span class="w">            </span><span class="n">block_id</span><span class="p">,</span>
<span class="w">            </span><span class="n">block_device</span><span class="p">,</span>
<span class="w">            </span><span class="n">modified</span>: <span class="nc">false</span><span class="p">,</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>一旦磁盘块已经存在于内存缓存中，CPU 就可以直接访问磁盘块数据了：</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="c1">// easy-fs/src/block_cache.rs</span>
<span class="linenos"> 2</span>
<span class="linenos"> 3</span><span class="k">impl</span><span class="w"> </span><span class="n">BlockCache</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 4</span><span class="w">    </span><span class="k">fn</span> <span class="nf">addr_of_offset</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span> <span class="p">{</span>
<span class="linenos"> 5</span><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">cache</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span>
<span class="linenos"> 6</span><span class="w">    </span><span class="p">}</span>
<span class="linenos"> 7</span>
<span class="linenos"> 8</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">get_ref</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">T</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">T</span>: <span class="nb">Sized</span> <span class="p">{</span>
<span class="linenos"> 9</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">type_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">core</span>::<span class="n">mem</span>::<span class="n">size_of</span>::<span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">();</span>
<span class="linenos">10</span><span class="w">        </span><span class="fm">assert!</span><span class="p">(</span><span class="n">offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">type_size</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">BLOCK_SZ</span><span class="p">);</span>
<span class="linenos">11</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">addr_of_offset</span><span class="p">(</span><span class="n">offset</span><span class="p">);</span>
<span class="linenos">12</span><span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">&amp;*</span><span class="p">(</span><span class="n">addr</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="linenos">13</span><span class="w">    </span><span class="p">}</span>
<span class="linenos">14</span>
<span class="linenos">15</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">get_mut</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">T</span>: <span class="nb">Sized</span> <span class="p">{</span>
<span class="linenos">16</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">type_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">core</span>::<span class="n">mem</span>::<span class="n">size_of</span>::<span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">();</span>
<span class="linenos">17</span><span class="w">        </span><span class="fm">assert!</span><span class="p">(</span><span class="n">offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">type_size</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">BLOCK_SZ</span><span class="p">);</span>
<span class="linenos">18</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">modified</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span>
<span class="linenos">19</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">addr_of_offset</span><span class="p">(</span><span class="n">offset</span><span class="p">);</span>
<span class="linenos">20</span><span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">addr</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="linenos">21</span><span class="w">    </span><span class="p">}</span>
<span class="linenos">22</span><span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">addr_of_offset</span></code> 可以得到一个 <code class="docutils literal notranslate"><span class="pre">BlockCache</span></code> 内部的缓冲区中指定偏移量 <code class="docutils literal notranslate"><span class="pre">offset</span></code> 的字节地址；</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">get_ref</span></code> 是一个泛型方法，它可以获取缓冲区中的位于偏移量 <code class="docutils literal notranslate"><span class="pre">offset</span></code> 的一个类型为 <code class="docutils literal notranslate"><span class="pre">T</span></code> 的磁盘上数据结构的不可变引用。该泛型方法的 Trait Bound 限制类型 <code class="docutils literal notranslate"><span class="pre">T</span></code> 必须是一个编译时已知大小的类型，我们通过 <code class="docutils literal notranslate"><span class="pre">core::mem::size_of::&lt;T&gt;()</span></code> 在编译时获取类型 <code class="docutils literal notranslate"><span class="pre">T</span></code> 的大小，并确认该数据结构被整个包含在磁盘块及其缓冲区之内。这里编译器会自动进行生命周期标注，约束返回的引用的生命周期不超过 <code class="docutils literal notranslate"><span class="pre">BlockCache</span></code> 自身，在使用的时候我们会保证这一点。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">get_mut</span></code> 与 <code class="docutils literal notranslate"><span class="pre">get_ref</span></code> 的不同之处在于， <code class="docutils literal notranslate"><span class="pre">get_mut</span></code> 会获取磁盘上数据结构的可变引用，由此可以对数据结构进行修改。由于这些数据结构目前位于内存中的缓冲区中，我们需要将 <code class="docutils literal notranslate"><span class="pre">BlockCache</span></code> 的 <code class="docutils literal notranslate"><span class="pre">modified</span></code> 标记为 true 表示该缓冲区已经被修改，之后需要将数据写回磁盘块才能真正将修改同步到磁盘。</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">BlockCache</span></code> 的设计也体现了 RAII 思想， 它管理着一个缓冲区的生命周期。当 <code class="docutils literal notranslate"><span class="pre">BlockCache</span></code> 的生命周期结束之后缓冲区也会被从内存中回收，这个时候 <code class="docutils literal notranslate"><span class="pre">modified</span></code> 标记将会决定数据是否需要写回磁盘：</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// easy-fs/src/block_cache.rs</span>

<span class="k">impl</span><span class="w"> </span><span class="n">BlockCache</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">sync</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">modified</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">modified</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">block_device</span><span class="p">.</span><span class="n">write_block</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">block_id</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">cache</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="w"> </span><span class="nb">Drop</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">BlockCache</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">sync</span><span class="p">()</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在 <code class="docutils literal notranslate"><span class="pre">BlockCache</span></code> 被 <code class="docutils literal notranslate"><span class="pre">drop</span></code> 的时候，它会首先调用 <code class="docutils literal notranslate"><span class="pre">sync</span></code> 方法，如果自身确实被修改过的话才会将缓冲区的内容写回磁盘。事实上， <code class="docutils literal notranslate"><span class="pre">sync</span></code> 并不是只有在 <code class="docutils literal notranslate"><span class="pre">drop</span></code> 的时候才会被调用。在 Linux 中，通常有一个后台进程负责定期将内存中缓冲区的内容写回磁盘。另外有一个 <code class="docutils literal notranslate"><span class="pre">sys_fsync</span></code> 系统调用可以让应用主动通知内核将一个文件的修改同步回磁盘。由于我们的实现比较简单， <code class="docutils literal notranslate"><span class="pre">sync</span></code> 仅会在 <code class="docutils literal notranslate"><span class="pre">BlockCache</span></code> 被 <code class="docutils literal notranslate"><span class="pre">drop</span></code> 时才会被调用。</p>
<p>我们可以将 <code class="docutils literal notranslate"><span class="pre">get_ref/get_mut</span></code> 进一步封装为更为易用的形式：</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// easy-fs/src/block_cache.rs</span>

<span class="k">impl</span><span class="w"> </span><span class="n">BlockCache</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">read</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">impl</span><span class="w"> </span><span class="nb">FnOnce</span><span class="p">(</span><span class="o">&amp;</span><span class="n">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">V</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">V</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">f</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">get_ref</span><span class="p">(</span><span class="n">offset</span><span class="p">))</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">modify</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span>:<span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">impl</span><span class="w"> </span><span class="nb">FnOnce</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">V</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">V</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">f</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">get_mut</span><span class="p">(</span><span class="n">offset</span><span class="p">))</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>它们的含义是：在 <code class="docutils literal notranslate"><span class="pre">BlockCache</span></code> 缓冲区偏移量为 <code class="docutils literal notranslate"><span class="pre">offset</span></code> 的位置获取一个类型为 <code class="docutils literal notranslate"><span class="pre">T</span></code> 的磁盘上数据结构的不可变/可变引用（分别对应 <code class="docutils literal notranslate"><span class="pre">read/modify</span></code> ），并让它执行传入的闭包 <code class="docutils literal notranslate"><span class="pre">f</span></code> 中所定义的操作。注意 <code class="docutils literal notranslate"><span class="pre">read/modify</span></code> 的返回值是和传入闭包的返回值相同的，因此相当于 <code class="docutils literal notranslate"><span class="pre">read/modify</span></code> 构成了传入闭包 <code class="docutils literal notranslate"><span class="pre">f</span></code> 的一层执行环境，让它能够绑定到一个缓冲区上执行。</p>
<p>这里我们传入闭包的类型为 <code class="docutils literal notranslate"><span class="pre">FnOnce</span></code> ，这是因为闭包里面的变量被捕获的方式涵盖了不可变引用/可变引用/和 move 三种可能性，故而我们需要选取范围最广的 <code class="docutils literal notranslate"><span class="pre">FnOnce</span></code> 。参数中的 <code class="docutils literal notranslate"><span class="pre">impl</span></code> 关键字体现了一种类似泛型的静态分发功能。</p>
<p>我们很快将展示 <code class="docutils literal notranslate"><span class="pre">read/modify</span></code> 接口如何在后续的开发中提供便利。</p>
</div>
<div class="section" id="id6">
<h3>块缓存全局管理器<a class="headerlink" href="#id6" title="永久链接至标题">#</a></h3>
<p>为了避免在块缓存上浪费过多内存，我们希望内存中同时只能驻留有限个磁盘块的缓冲区：</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// easy-fs/src/block_cache.rs</span>

<span class="k">const</span><span class="w"> </span><span class="n">BLOCK_CACHE_SIZE</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span>
</pre></div>
</div>
<p>块缓存全局管理器的功能是：当我们要对一个磁盘块进行读写时，首先看它是否已经被载入到内存缓存中了，如果已经被载入的话则直接返回，否则需要先读取磁盘块的数据到内存缓存中。此时，如果内存中驻留的磁盘块缓冲区的数量已满，则需要遵循某种缓存替换算法将某个块的缓存从内存中移除，再将刚刚读到的块数据加入到内存缓存中。我们这里使用一种类 FIFO 的简单缓存替换算法，因此在管理器中只需维护一个队列：</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// easy-fs/src/block_cache.rs</span>

<span class="k">use</span><span class="w"> </span><span class="n">alloc</span>::<span class="n">collections</span>::<span class="n">VecDeque</span><span class="p">;</span>

<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">BlockCacheManager</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">queue</span>: <span class="nc">VecDeque</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">Arc</span><span class="o">&lt;</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="n">BlockCache</span><span class="o">&gt;&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="w"> </span><span class="n">BlockCacheManager</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">queue</span>: <span class="nc">VecDeque</span>::<span class="n">new</span><span class="p">()</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>队列 <code class="docutils literal notranslate"><span class="pre">queue</span></code> 中管理的是块编号和块缓存的二元组。块编号的类型为 <code class="docutils literal notranslate"><span class="pre">usize</span></code> ，而块缓存的类型则是一个 <code class="docutils literal notranslate"><span class="pre">Arc&lt;Mutex&lt;BlockCache&gt;&gt;</span></code> 。这是一个此前频频提及到的 Rust 中的经典组合，它可以同时提供共享引用和互斥访问。这里的共享引用意义在于块缓存既需要在管理器 <code class="docutils literal notranslate"><span class="pre">BlockCacheManager</span></code> 保留一个引用，还需要以引用的形式返回给块缓存的请求者让它可以对块缓存进行访问。而互斥访问在单核上的意义在于提供内部可变性通过编译，在多核环境下则可以帮助我们避免可能的并发冲突。事实上，一般情况下我们需要在更上层提供保护措施避免两个线程同时对一个块缓存进行读写，因此这里只是比较谨慎的留下一层保险。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>Rust Pattern卡片： <code class="docutils literal notranslate"><span class="pre">Arc&lt;Mutex&lt;?&gt;&gt;</span></code></p>
<p>先看下Arc和Mutex的正确配合可以达到支持多线程安全读写数据对象。如果需要多线程共享所有权的数据对象，则只用Arc即可。如果需要修改 <code class="docutils literal notranslate"><span class="pre">T</span></code> 类型中某些成员变量 <code class="docutils literal notranslate"><span class="pre">member</span></code> ，那直接采用 <code class="docutils literal notranslate"><span class="pre">Arc&lt;Mutex&lt;T&gt;&gt;</span></code> ，并在修改的时候通过  <code class="docutils literal notranslate"><span class="pre">obj.lock().unwrap().member</span> <span class="pre">=</span> <span class="pre">xxx</span></code> 的方式是可行的，但这种编程模式的同步互斥的粒度太大，可能对互斥性能的影响比较大。为了减少互斥性能开销，其实只需要在 <code class="docutils literal notranslate"><span class="pre">T</span></code> 类型中的需要被修改的成员变量上加 <code class="docutils literal notranslate"><span class="pre">Mutex&lt;_&gt;</span></code> 即可。如果成员变量也是一个数据结构，还包含更深层次的成员变量，那应该继续下推到最终需要修改的成员变量上去添加 <code class="docutils literal notranslate"><span class="pre">Mutex</span></code> 。</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">get_block_cache</span></code> 方法尝试从块缓存管理器中获取一个编号为 <code class="docutils literal notranslate"><span class="pre">block_id</span></code> 的块的块缓存，如果找不到，会从磁盘读取到内存中，还有可能会发生缓存替换：</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="c1">// easy-fs/src/block_cache.rs</span>
<span class="linenos"> 2</span>
<span class="linenos"> 3</span><span class="k">impl</span><span class="w"> </span><span class="n">BlockCacheManager</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 4</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">get_block_cache</span><span class="p">(</span>
<span class="linenos"> 5</span><span class="w">        </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span>
<span class="linenos"> 6</span><span class="w">        </span><span class="n">block_id</span>: <span class="kt">usize</span><span class="p">,</span>
<span class="linenos"> 7</span><span class="w">        </span><span class="n">block_device</span>: <span class="nc">Arc</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">BlockDevice</span><span class="o">&gt;</span><span class="p">,</span>
<span class="linenos"> 8</span><span class="w">    </span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Arc</span><span class="o">&lt;</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="n">BlockCache</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 9</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">queue</span>
<span class="linenos">10</span><span class="w">            </span><span class="p">.</span><span class="n">iter</span><span class="p">()</span>
<span class="linenos">11</span><span class="w">            </span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="o">|</span><span class="n">pair</span><span class="o">|</span><span class="w"> </span><span class="n">pair</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">block_id</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">12</span><span class="w">                </span><span class="n">Arc</span>::<span class="n">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pair</span><span class="p">.</span><span class="mi">1</span><span class="p">)</span>
<span class="linenos">13</span><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">14</span><span class="w">            </span><span class="c1">// substitute</span>
<span class="linenos">15</span><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">queue</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">BLOCK_CACHE_SIZE</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">16</span><span class="w">                </span><span class="c1">// from front to tail</span>
<span class="linenos">17</span><span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">((</span><span class="n">idx</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">))</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">queue</span>
<span class="linenos">18</span><span class="w">                    </span><span class="p">.</span><span class="n">iter</span><span class="p">()</span>
<span class="linenos">19</span><span class="w">                    </span><span class="p">.</span><span class="n">enumerate</span><span class="p">()</span>
<span class="linenos">20</span><span class="w">                    </span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="o">|</span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">pair</span><span class="p">)</span><span class="o">|</span><span class="w"> </span><span class="n">Arc</span>::<span class="n">strong_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pair</span><span class="p">.</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">21</span><span class="w">                    </span><span class="bp">self</span><span class="p">.</span><span class="n">queue</span><span class="p">.</span><span class="n">drain</span><span class="p">(</span><span class="n">idx</span><span class="o">..=</span><span class="n">idx</span><span class="p">);</span>
<span class="linenos">22</span><span class="w">                </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">23</span><span class="w">                    </span><span class="fm">panic!</span><span class="p">(</span><span class="s">&quot;Run out of BlockCache!&quot;</span><span class="p">);</span>
<span class="linenos">24</span><span class="w">                </span><span class="p">}</span>
<span class="linenos">25</span><span class="w">            </span><span class="p">}</span>
<span class="linenos">26</span><span class="w">            </span><span class="c1">// load block into mem and push back</span>
<span class="linenos">27</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">block_cache</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Arc</span>::<span class="n">new</span><span class="p">(</span><span class="n">Mutex</span>::<span class="n">new</span><span class="p">(</span>
<span class="linenos">28</span><span class="w">                </span><span class="n">BlockCache</span>::<span class="n">new</span><span class="p">(</span><span class="n">block_id</span><span class="p">,</span><span class="w"> </span><span class="n">Arc</span>::<span class="n">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_device</span><span class="p">))</span>
<span class="linenos">29</span><span class="w">            </span><span class="p">));</span>
<span class="linenos">30</span><span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">queue</span><span class="p">.</span><span class="n">push_back</span><span class="p">((</span><span class="n">block_id</span><span class="p">,</span><span class="w"> </span><span class="n">Arc</span>::<span class="n">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_cache</span><span class="p">)));</span>
<span class="linenos">31</span><span class="w">            </span><span class="n">block_cache</span>
<span class="linenos">32</span><span class="w">        </span><span class="p">}</span>
<span class="linenos">33</span><span class="w">    </span><span class="p">}</span>
<span class="linenos">34</span><span class="p">}</span>
</pre></div>
</div>
<ul>
<li><p>第 9 行会遍历整个队列试图找到一个编号相同的块缓存，如果找到了，会将块缓存管理器中保存的块缓存的引用复制一份并返回；</p></li>
<li><p>第 13 行对应找不到的情况，此时必须将块从磁盘读入内存中的缓冲区。在实际读取之前，需要判断管理器保存的块缓存数量是否已经达到了上限。如果达到了上限（第 15 行）才需要执行缓存替换算法，丢掉某个块缓存并空出一个空位。这里使用一种类 FIFO 算法：每加入一个块缓存时要从队尾加入；要替换时则从队头弹出。但此时队头对应的块缓存可能仍在使用：判断的标志是其强引用计数 <span class="math notranslate nohighlight">\(\geq 2\)</span> ，即除了块缓存管理器保留的一份副本之外，在外面还有若干份副本正在使用。因此，我们的做法是从队头遍历到队尾找到第一个强引用计数恰好为 1 的块缓存并将其替换出去。</p>
<p>那么是否有可能出现队列已满且其中所有的块缓存都正在使用的情形呢？事实上，只要我们的上限 <code class="docutils literal notranslate"><span class="pre">BLOCK_CACHE_SIZE</span></code> 设置的足够大，超过所有应用同时访问的块总数上限，那么这种情况永远不会发生。但是，如果我们的上限设置不足，内核将 panic （基于简单内核设计的思路）。</p>
</li>
<li><p>第 27 行开始我们创建一个新的块缓存（会触发 <code class="docutils literal notranslate"><span class="pre">read_block</span></code> 进行块读取）并加入到队尾，最后返回给请求者。</p></li>
</ul>
<p>接下来需要创建 <code class="docutils literal notranslate"><span class="pre">BlockCacheManager</span></code> 的全局实例：</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// easy-fs/src/block_cache.rs</span>

<span class="n">lazy_static</span><span class="o">!</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">ref</span><span class="w"> </span><span class="n">BLOCK_CACHE_MANAGER</span>: <span class="nc">Mutex</span><span class="o">&lt;</span><span class="n">BlockCacheManager</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Mutex</span>::<span class="n">new</span><span class="p">(</span>
<span class="w">        </span><span class="n">BlockCacheManager</span>::<span class="n">new</span><span class="p">()</span>
<span class="w">    </span><span class="p">);</span>
<span class="p">}</span>

<span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">get_block_cache</span><span class="p">(</span>
<span class="w">    </span><span class="n">block_id</span>: <span class="kt">usize</span><span class="p">,</span>
<span class="w">    </span><span class="n">block_device</span>: <span class="nc">Arc</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">BlockDevice</span><span class="o">&gt;</span>
<span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Arc</span><span class="o">&lt;</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="n">BlockCache</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">BLOCK_CACHE_MANAGER</span><span class="p">.</span><span class="n">lock</span><span class="p">().</span><span class="n">get_block_cache</span><span class="p">(</span><span class="n">block_id</span><span class="p">,</span><span class="w"> </span><span class="n">block_device</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这样对于其他模块而言，就可以直接通过 <code class="docutils literal notranslate"><span class="pre">get_block_cache</span></code> 方法来请求块缓存了。这里需要指出的是，它返回的是一个 <code class="docutils literal notranslate"><span class="pre">Arc&lt;Mutex&lt;BlockCache&gt;&gt;</span></code> ，调用者需要通过 <code class="docutils literal notranslate"><span class="pre">.lock()</span></code> 获取里层互斥锁 <code class="docutils literal notranslate"><span class="pre">Mutex</span></code> 才能对最里面的 <code class="docutils literal notranslate"><span class="pre">BlockCache</span></code> 进行操作，比如通过 <code class="docutils literal notranslate"><span class="pre">read/modify</span></code> 访问缓冲区里面的磁盘数据结构。</p>
</div>
</div>
<div class="section" id="id7">
<h2>磁盘布局及磁盘上数据结构<a class="headerlink" href="#id7" title="永久链接至标题">#</a></h2>
<p>磁盘数据结构层的代码在 <code class="docutils literal notranslate"><span class="pre">layout.rs</span></code> 和 <code class="docutils literal notranslate"><span class="pre">bitmap.rs</span></code> 中。</p>
<p>对于一个文件系统而言，最重要的功能是如何将一个逻辑上的文件目录树结构映射到磁盘上，决定磁盘上的每个块应该存储文件相关的哪些数据。为了更容易进行管理和更新，我们需要将磁盘上的数据组织为若干种不同的磁盘上数据结构，并合理安排它们在磁盘中的位置。</p>
<div class="section" id="id8">
<h3>easy-fs 磁盘布局概述<a class="headerlink" href="#id8" title="永久链接至标题">#</a></h3>
<p>在 easy-fs 磁盘布局中，按照块编号从小到大顺序地分成 5 个不同属性的连续区域：</p>
<ul class="simple">
<li><p>最开始的区域的长度为一个块，其内容是 easy-fs <strong>超级块</strong> (Super Block)。超级块内以魔数的形式提供了文件系统合法性检查功能，同时还可以定位其他连续区域的位置。</p></li>
<li><p>第二个区域是一个索引节点位图，长度为若干个块。它记录了后面的索引节点区域中有哪些索引节点已经被分配出去使用了，而哪些还尚未被分配出去。</p></li>
<li><p>第三个区域是索引节点区域，长度为若干个块。其中的每个块都存储了若干个索引节点。</p></li>
<li><p>第四个区域是一个数据块位图，长度为若干个块。它记录了后面的数据块区域中有哪些数据块已经被分配出去使用了，而哪些还尚未被分配出去。</p></li>
<li><p>最后的区域则是数据块区域，顾名思义，其中的每一个已经分配出去的块保存了文件或目录中的具体数据内容。</p></li>
</ul>
<p>easy-fs 的磁盘布局如下图所示：</p>
<img alt="../_images/文件系统布局.png" src="../_images/文件系统布局.png" />
<p><strong>索引节点</strong> (Inode, Index Node) 是文件系统中的一种重要数据结构。逻辑目录树结构中的每个文件和目录都对应一个 inode ，我们前面提到的文件系统实现中，文件/目录的底层编号实际上就是指 inode 编号。在 inode 中不仅包含了我们通过 <code class="docutils literal notranslate"><span class="pre">stat</span></code> 工具能够看到的文件/目录的元数据（大小/访问权限/类型等信息），还包含实际保存对应文件/目录数据的数据块（位于最后的数据块区域中）的索引信息，从而能够找到文件/目录的数据被保存在磁盘的哪些块中。从索引方式上看，同时支持直接索引和间接索引。</p>
<p>每个区域中均存储着不同的磁盘数据结构， <code class="docutils literal notranslate"><span class="pre">easy-fs</span></code> 文件系统能够对磁盘中的数据进行解释并将其结构化。下面我们分别对它们进行介绍。</p>
</div>
<div class="section" id="id9">
<h3>easy-fs 超级块<a class="headerlink" href="#id9" title="永久链接至标题">#</a></h3>
<p>超级块 <code class="docutils literal notranslate"><span class="pre">SuperBlock</span></code> 的内容如下：</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// easy-fs/src/layout.rs</span>

<span class="cp">#[repr(C)]</span>
<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">SuperBlock</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">magic</span>: <span class="kt">u32</span><span class="p">,</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">total_blocks</span>: <span class="kt">u32</span><span class="p">,</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">inode_bitmap_blocks</span>: <span class="kt">u32</span><span class="p">,</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">inode_area_blocks</span>: <span class="kt">u32</span><span class="p">,</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">data_bitmap_blocks</span>: <span class="kt">u32</span><span class="p">,</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">data_area_blocks</span>: <span class="kt">u32</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>
</div>
<p>其中， <code class="docutils literal notranslate"><span class="pre">magic</span></code> 是一个用于文件系统合法性验证的魔数， <code class="docutils literal notranslate"><span class="pre">total_block</span></code> 给出文件系统的总块数。注意这并不等同于所在磁盘的总块数，因为文件系统很可能并没有占据整个磁盘。后面的四个字段则分别给出 easy-fs 布局中后四个连续区域的长度各为多少个块。</p>
<p>下面是它实现的方法：</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// easy-fs/src/layout.rs</span>

<span class="k">impl</span><span class="w"> </span><span class="n">SuperBlock</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">initialize</span><span class="p">(</span>
<span class="w">        </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span>
<span class="w">        </span><span class="n">total_blocks</span>: <span class="kt">u32</span><span class="p">,</span>
<span class="w">        </span><span class="n">inode_bitmap_blocks</span>: <span class="kt">u32</span><span class="p">,</span>
<span class="w">        </span><span class="n">inode_area_blocks</span>: <span class="kt">u32</span><span class="p">,</span>
<span class="w">        </span><span class="n">data_bitmap_blocks</span>: <span class="kt">u32</span><span class="p">,</span>
<span class="w">        </span><span class="n">data_area_blocks</span>: <span class="kt">u32</span><span class="p">,</span>
<span class="w">    </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="o">*</span><span class="bp">self</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">magic</span>: <span class="nc">EFS_MAGIC</span><span class="p">,</span>
<span class="w">            </span><span class="n">total_blocks</span><span class="p">,</span>
<span class="w">            </span><span class="n">inode_bitmap_blocks</span><span class="p">,</span>
<span class="w">            </span><span class="n">inode_area_blocks</span><span class="p">,</span>
<span class="w">            </span><span class="n">data_bitmap_blocks</span><span class="p">,</span>
<span class="w">            </span><span class="n">data_area_blocks</span><span class="p">,</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">is_valid</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">magic</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">EFS_MAGIC</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">initialize</span></code> 可以在创建一个 easy-fs 的时候对超级块进行初始化，注意各个区域的块数是以参数的形式传入进来的，它们的划分是更上层的磁盘块管理器需要完成的工作。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">is_valid</span></code> 则可以通过魔数判断超级块所在的文件系统是否合法。</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">SuperBlock</span></code> 是一个磁盘上数据结构，它就存放在磁盘上编号为 0 的块的起始处。</p>
</div>
<div class="section" id="id10">
<h3>位图<a class="headerlink" href="#id10" title="永久链接至标题">#</a></h3>
<p>在 easy-fs 布局中存在两类不同的位图，分别对索引节点和数据块进行管理。每个位图都由若干个块组成，每个块大小为 512 bytes，即 4096 bits。每个 bit 都代表一个索引节点/数据块的分配状态， 0 意味着未分配，而 1 则意味着已经分配出去。位图所要做的事情是通过基于 bit 为单位的分配（寻找一个为 0 的bit位并设置为 1）和回收（将bit位清零）来进行索引节点/数据块的分配和回收。</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// easy-fs/src/bitmap.rs</span>

<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Bitmap</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">start_block_id</span>: <span class="kt">usize</span><span class="p">,</span>
<span class="w">    </span><span class="n">blocks</span>: <span class="kt">usize</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="w"> </span><span class="n">Bitmap</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">start_block_id</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">blocks</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">start_block_id</span><span class="p">,</span>
<span class="w">            </span><span class="n">blocks</span><span class="p">,</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>位图 <code class="docutils literal notranslate"><span class="pre">Bitmap</span></code> 中仅保存了它所在区域的起始块编号以及区域的长度为多少个块。通过 <code class="docutils literal notranslate"><span class="pre">new</span></code> 方法可以新建一个位图。注意 <code class="docutils literal notranslate"><span class="pre">Bitmap</span></code> 自身是驻留在内存中的，但是它能够表示索引节点/数据块区域中的那些磁盘块的分配情况。磁盘块上位图区域的数据则是要以磁盘数据结构 <code class="docutils literal notranslate"><span class="pre">BitmapBlock</span></code> 的格式进行操作：</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// easy-fs/src/bitmap.rs</span>

<span class="k">type</span> <span class="nc">BitmapBlock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="kt">u64</span><span class="p">;</span><span class="w"> </span><span class="mi">64</span><span class="p">];</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">BitmapBlock</span></code> 是一个磁盘数据结构，它将位图区域中的一个磁盘块解释为长度为 64 的一个 <code class="docutils literal notranslate"><span class="pre">u64</span></code> 数组， 每个 <code class="docutils literal notranslate"><span class="pre">u64</span></code> 打包了一组 64 bits，于是整个数组包含 <span class="math notranslate nohighlight">\(64\times 64=4096\)</span> bits，且可以以组为单位进行操作。</p>
<p>首先来看 <code class="docutils literal notranslate"><span class="pre">Bitmap</span></code> 如何分配一个bit：</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="c1">// easy-fs/src/bitmap.rs</span>
<span class="linenos"> 2</span>
<span class="linenos"> 3</span><span class="k">const</span><span class="w"> </span><span class="n">BLOCK_BITS</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="n">BLOCK_SZ</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span>
<span class="linenos"> 4</span>
<span class="linenos"> 5</span><span class="k">impl</span><span class="w"> </span><span class="n">Bitmap</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 6</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">block_device</span>: <span class="kp">&amp;</span><span class="nc">Arc</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">BlockDevice</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 7</span><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">block_id</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="bp">self</span><span class="p">.</span><span class="n">blocks</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 8</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_block_cache</span><span class="p">(</span>
<span class="linenos"> 9</span><span class="w">                </span><span class="n">block_id</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">start_block_id</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span>
<span class="linenos">10</span><span class="w">                </span><span class="n">Arc</span>::<span class="n">clone</span><span class="p">(</span><span class="n">block_device</span><span class="p">),</span>
<span class="linenos">11</span><span class="w">            </span><span class="p">)</span>
<span class="linenos">12</span><span class="w">            </span><span class="p">.</span><span class="n">lock</span><span class="p">()</span>
<span class="linenos">13</span><span class="w">            </span><span class="p">.</span><span class="n">modify</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">bitmap_block</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">BitmapBlock</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">14</span><span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">((</span><span class="n">bits64_pos</span><span class="p">,</span><span class="w"> </span><span class="n">inner_pos</span><span class="p">))</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bitmap_block</span>
<span class="linenos">15</span><span class="w">                    </span><span class="p">.</span><span class="n">iter</span><span class="p">()</span>
<span class="linenos">16</span><span class="w">                    </span><span class="p">.</span><span class="n">enumerate</span><span class="p">()</span>
<span class="linenos">17</span><span class="w">                    </span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="o">|</span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">bits64</span><span class="p">)</span><span class="o">|</span><span class="w"> </span><span class="o">**</span><span class="n">bits64</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kt">u64</span>::<span class="n">MAX</span><span class="p">)</span>
<span class="linenos">18</span><span class="w">                    </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="p">(</span><span class="n">bits64_pos</span><span class="p">,</span><span class="w"> </span><span class="n">bits64</span><span class="p">)</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">19</span><span class="w">                        </span><span class="p">(</span><span class="n">bits64_pos</span><span class="p">,</span><span class="w"> </span><span class="n">bits64</span><span class="p">.</span><span class="n">trailing_ones</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span>
<span class="linenos">20</span><span class="w">                    </span><span class="p">})</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">21</span><span class="w">                    </span><span class="c1">// modify cache</span>
<span class="linenos">22</span><span class="w">                    </span><span class="n">bitmap_block</span><span class="p">[</span><span class="n">bits64_pos</span><span class="p">]</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="mi">1</span><span class="k">u64</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">inner_pos</span><span class="p">;</span>
<span class="linenos">23</span><span class="w">                    </span><span class="nb">Some</span><span class="p">(</span><span class="n">block_id</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">BLOCK_BITS</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">bits64_pos</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">64</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">inner_pos</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span>
<span class="linenos">24</span><span class="w">                </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">25</span><span class="w">                    </span><span class="nb">None</span>
<span class="linenos">26</span><span class="w">                </span><span class="p">}</span>
<span class="linenos">27</span><span class="w">            </span><span class="p">});</span>
<span class="linenos">28</span><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">pos</span><span class="p">.</span><span class="n">is_some</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">29</span><span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">pos</span><span class="p">;</span>
<span class="linenos">30</span><span class="w">            </span><span class="p">}</span>
<span class="linenos">31</span><span class="w">        </span><span class="p">}</span>
<span class="linenos">32</span><span class="w">        </span><span class="nb">None</span>
<span class="linenos">33</span><span class="w">    </span><span class="p">}</span>
<span class="linenos">34</span><span class="p">}</span>
</pre></div>
</div>
<p>其主要思路是遍历区域中的每个块，再在每个块中以bit组（每组 64 bits）为单位进行遍历，找到一个尚未被全部分配出去的组，最后在里面分配一个bit。它将会返回分配的bit所在的位置，等同于索引节点/数据块的编号。如果所有bit均已经被分配出去了，则返回 <code class="docutils literal notranslate"><span class="pre">None</span></code> 。</p>
<p>第 7 行枚举区域中的每个块（编号为 <code class="docutils literal notranslate"><span class="pre">block_id</span></code> ），在循环内部我们需要读写这个块，在块内尝试找到一个空闲的bit并置 1 。一旦涉及到块的读写，就需要用到块缓存层提供的接口：</p>
<ul>
<li><p>第 8 行我们调用 <code class="docutils literal notranslate"><span class="pre">get_block_cache</span></code> 获取块缓存，注意我们传入的块编号是区域起始块编号 <code class="docutils literal notranslate"><span class="pre">start_block_id</span></code> 加上区域内的块编号 <code class="docutils literal notranslate"><span class="pre">block_id</span></code> 得到的块设备上的块编号。</p></li>
<li><p>第 12 行我们通过 <code class="docutils literal notranslate"><span class="pre">.lock()</span></code> 获取块缓存的互斥锁从而可以对块缓存进行访问。</p></li>
<li><p>第 13 行我们使用到了 <code class="docutils literal notranslate"><span class="pre">BlockCache::modify</span></code> 接口。它传入的偏移量 <code class="docutils literal notranslate"><span class="pre">offset</span></code> 为 0，这是因为整个块上只有一个 <code class="docutils literal notranslate"><span class="pre">BitmapBlock</span></code> ，它的大小恰好为 512 字节。因此我们需要从块的开头开始才能访问到完整的 <code class="docutils literal notranslate"><span class="pre">BitmapBlock</span></code> 。同时，传给它的闭包需要显式声明参数类型为 <code class="docutils literal notranslate"><span class="pre">&amp;mut</span> <span class="pre">BitmapBlock</span></code> ，不然的话， <code class="docutils literal notranslate"><span class="pre">BlockCache</span></code> 的泛型方法 <code class="docutils literal notranslate"><span class="pre">modify/get_mut</span></code> 无法得知应该用哪个类型来解析块上的数据。在声明之后，编译器才能在这里将两个方法中的泛型 <code class="docutils literal notranslate"><span class="pre">T</span></code> 实例化为具体类型 <code class="docutils literal notranslate"><span class="pre">BitmapBlock</span></code> 。</p>
<p>总结一下，这里 <code class="docutils literal notranslate"><span class="pre">modify</span></code> 的含义就是：从缓冲区偏移量为 0 的位置开始将一段连续的数据（数据的长度随具体类型而定）解析为一个 <code class="docutils literal notranslate"><span class="pre">BitmapBlock</span></code> 并要对该数据结构进行修改。在闭包内部，我们可以使用这个 <code class="docutils literal notranslate"><span class="pre">BitmapBlock</span></code> 的可变引用 <code class="docutils literal notranslate"><span class="pre">bitmap_block</span></code> 对它进行访问。 <code class="docutils literal notranslate"><span class="pre">read/get_ref</span></code> 的用法完全相同，后面将不再赘述。</p>
</li>
<li><p>闭包的主体位于第 14~26 行。它尝试在 <code class="docutils literal notranslate"><span class="pre">bitmap_block</span></code> 中找到一个空闲的bit并返回其位置，如果不存在的话则返回 <code class="docutils literal notranslate"><span class="pre">None</span></code> 。它的思路是，遍历每 64 bits构成的组（一个 <code class="docutils literal notranslate"><span class="pre">u64</span></code> ），如果它并没有达到 <code class="docutils literal notranslate"><span class="pre">u64::MAX</span></code> （即 <span class="math notranslate nohighlight">\(2^{64}-1\)</span> ），则通过 <code class="docutils literal notranslate"><span class="pre">u64::trailing_ones</span></code> 找到最低的一个 0 并置为 1 。如果能够找到的话，bit组的编号将保存在变量 <code class="docutils literal notranslate"><span class="pre">bits64_pos</span></code> 中，而分配的bit在组内的位置将保存在变量 <code class="docutils literal notranslate"><span class="pre">inner_pos</span></code> 中。在返回分配的bit编号的时候，它的计算方式是 <code class="docutils literal notranslate"><span class="pre">block_id*BLOCK_BITS+bits64_pos*64+inner_pos</span></code> 。注意闭包中的 <code class="docutils literal notranslate"><span class="pre">block_id</span></code> 并不在闭包的参数列表中，因此它是从外部环境（即自增 <code class="docutils literal notranslate"><span class="pre">block_id</span></code> 的循环）中捕获到的。</p></li>
</ul>
<p>我们一旦在某个块中找到一个空闲的bit并成功分配，就不再考虑后续的块。第 28 行体现了提前返回的思路。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p><strong>Rust 语法卡片：闭包</strong></p>
<p>闭包是持有外部环境变量的函数。所谓外部环境, 就是指创建闭包时所在的词法作用域。Rust中定义的闭包，按照对外部环境变量的使用方式（借用、复制、转移所有权），分为三个类型: Fn、FnMut、FnOnce。Fn类型的闭包会在闭包内部以共享借用的方式使用环境变量；FnMut类型的闭包会在闭包内部以独占借用的方式使用环境变量；而FnOnce类型的闭包会在闭包内部以所有者的身份使用环境变量。由此可见，根据闭包内使用环境变量的方式，即可判断创建出来的闭包的类型。</p>
</div>
<p>接下来看 <code class="docutils literal notranslate"><span class="pre">Bitmap</span></code> 如何回收一个bit：</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// easy-fs/src/bitmap.rs</span>

<span class="sd">/// Return (block_pos, bits64_pos, inner_pos)</span>
<span class="k">fn</span> <span class="nf">decomposition</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">bit</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="p">(</span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">block_pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bit</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">BLOCK_BITS</span><span class="p">;</span>
<span class="w">    </span><span class="n">bit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bit</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">BLOCK_BITS</span><span class="p">;</span>
<span class="w">    </span><span class="p">(</span><span class="n">block_pos</span><span class="p">,</span><span class="w"> </span><span class="n">bit</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">64</span><span class="p">,</span><span class="w"> </span><span class="n">bit</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">64</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">impl</span><span class="w"> </span><span class="n">Bitmap</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">dealloc</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">block_device</span>: <span class="kp">&amp;</span><span class="nc">Arc</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">BlockDevice</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">bit</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">block_pos</span><span class="p">,</span><span class="w"> </span><span class="n">bits64_pos</span><span class="p">,</span><span class="w"> </span><span class="n">inner_pos</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">decomposition</span><span class="p">(</span><span class="n">bit</span><span class="p">);</span>
<span class="w">        </span><span class="n">get_block_cache</span><span class="p">(</span>
<span class="w">            </span><span class="n">block_pos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">start_block_id</span><span class="p">,</span>
<span class="w">            </span><span class="n">Arc</span>::<span class="n">clone</span><span class="p">(</span><span class="n">block_device</span><span class="p">)</span>
<span class="w">        </span><span class="p">).</span><span class="n">lock</span><span class="p">().</span><span class="n">modify</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">bitmap_block</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">BitmapBlock</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="fm">assert!</span><span class="p">(</span><span class="n">bitmap_block</span><span class="p">[</span><span class="n">bits64_pos</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="k">u64</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">inner_pos</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">            </span><span class="n">bitmap_block</span><span class="p">[</span><span class="n">bits64_pos</span><span class="p">]</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mi">1</span><span class="k">u64</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">inner_pos</span><span class="p">;</span>
<span class="w">        </span><span class="p">});</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">dealloc</span></code> 方法首先调用 <code class="docutils literal notranslate"><span class="pre">decomposition</span></code> 函数将bit编号 <code class="docutils literal notranslate"><span class="pre">bit</span></code> 分解为区域中的块编号 <code class="docutils literal notranslate"><span class="pre">block_pos</span></code> 、块内的组编号 <code class="docutils literal notranslate"><span class="pre">bits64_pos</span></code> 以及组内编号 <code class="docutils literal notranslate"><span class="pre">inner_pos</span></code> 的三元组，这样就能精确定位待回收的bit，随后将其清零即可。</p>
</div>
<div class="section" id="id11">
<h3>磁盘上索引节点<a class="headerlink" href="#id11" title="永久链接至标题">#</a></h3>
<p>在磁盘上的索引节点区域，每个块上都保存着若干个索引节点 <code class="docutils literal notranslate"><span class="pre">DiskInode</span></code> ：</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// easy-fs/src/layout.rs</span>

<span class="k">const</span><span class="w"> </span><span class="n">INODE_DIRECT_COUNT</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="mi">28</span><span class="p">;</span>

<span class="cp">#[repr(C)]</span>
<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">DiskInode</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">size</span>: <span class="kt">u32</span><span class="p">,</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">direct</span>: <span class="p">[</span><span class="kt">u32</span><span class="p">;</span><span class="w"> </span><span class="n">INODE_DIRECT_COUNT</span><span class="p">],</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">indirect1</span>: <span class="kt">u32</span><span class="p">,</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">indirect2</span>: <span class="kt">u32</span><span class="p">,</span>
<span class="w">    </span><span class="n">type_</span>: <span class="nc">DiskInodeType</span><span class="p">,</span>
<span class="p">}</span>

<span class="cp">#[derive(PartialEq)]</span>
<span class="k">pub</span><span class="w"> </span><span class="k">enum</span> <span class="nc">DiskInodeType</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">File</span><span class="p">,</span>
<span class="w">    </span><span class="n">Directory</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>
</div>
<p>每个文件/目录在磁盘上均以一个 <code class="docutils literal notranslate"><span class="pre">DiskInode</span></code> 的形式存储。其中包含文件/目录的元数据： <code class="docutils literal notranslate"><span class="pre">size</span></code> 表示文件/目录内容的字节数， <code class="docutils literal notranslate"><span class="pre">type_</span></code> 表示索引节点的类型 <code class="docutils literal notranslate"><span class="pre">DiskInodeType</span></code> ，目前仅支持文件 <code class="docutils literal notranslate"><span class="pre">File</span></code> 和目录 <code class="docutils literal notranslate"><span class="pre">Directory</span></code> 两种类型。其余的 <code class="docutils literal notranslate"><span class="pre">direct/indirect1/indirect2</span></code> 都是存储文件内容/目录内容的数据块的索引，这也是索引节点名字的由来。</p>
<p>为了尽可能节约空间，在进行索引的时候，块的编号用一个 <code class="docutils literal notranslate"><span class="pre">u32</span></code> 存储。索引方式分成直接索引和间接索引两种：</p>
<ul class="simple">
<li><p>当文件很小的时候，只需用到直接索引， <code class="docutils literal notranslate"><span class="pre">direct</span></code> 数组中最多可以指向 <code class="docutils literal notranslate"><span class="pre">INODE_DIRECT_COUNT</span></code> 个数据块，当取值为 28 的时候，通过直接索引可以找到 14KiB 的内容。</p></li>
<li><p>当文件比较大的时候，不仅直接索引的 <code class="docutils literal notranslate"><span class="pre">direct</span></code> 数组装满，还需要用到一级间接索引 <code class="docutils literal notranslate"><span class="pre">indirect1</span></code> 。它指向一个一级索引块，这个块也位于磁盘布局的数据块区域中。这个一级索引块中的每个 <code class="docutils literal notranslate"><span class="pre">u32</span></code> 都用来指向数据块区域中一个保存该文件内容的数据块，因此，最多能够索引 <span class="math notranslate nohighlight">\(\frac{512}{4}=128\)</span> 个数据块，对应 64KiB 的内容。</p></li>
<li><p>当文件大小超过直接索引和一级索引支持的容量上限 78KiB 的时候，就需要用到二级间接索引 <code class="docutils literal notranslate"><span class="pre">indirect2</span></code> 。它指向一个位于数据块区域中的二级索引块。二级索引块中的每个 <code class="docutils literal notranslate"><span class="pre">u32</span></code> 指向一个不同的一级索引块，这些一级索引块也位于数据块区域中。因此，通过二级间接索引最多能够索引 <span class="math notranslate nohighlight">\(128\times 64\text{KiB}=8\text{MiB}\)</span> 的内容。</p></li>
</ul>
<p>为了充分利用空间，我们将 <code class="docutils literal notranslate"><span class="pre">DiskInode</span></code> 的大小设置为 128 字节，每个块正好能够容纳 4 个 <code class="docutils literal notranslate"><span class="pre">DiskInode</span></code> 。在后续需要支持更多类型的元数据的时候，可以适当缩减直接索引 <code class="docutils literal notranslate"><span class="pre">direct</span></code> 的块数，并将节约出来的空间用来存放其他元数据，仍可保证 <code class="docutils literal notranslate"><span class="pre">DiskInode</span></code> 的总大小为 128 字节。</p>
<p>通过 <code class="docutils literal notranslate"><span class="pre">initialize</span></code> 方法可以初始化一个 <code class="docutils literal notranslate"><span class="pre">DiskInode</span></code> 为一个文件或目录：</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// easy-fs/src/layout.rs</span>

<span class="k">impl</span><span class="w"> </span><span class="n">DiskInode</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="sd">/// indirect1 and indirect2 block are allocated only when they are needed.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">initialize</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">type_</span>: <span class="nc">DiskInodeType</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">direct</span><span class="p">.</span><span class="n">iter_mut</span><span class="p">().</span><span class="n">for_each</span><span class="p">(</span><span class="o">|</span><span class="n">v</span><span class="o">|</span><span class="w"> </span><span class="o">*</span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">indirect1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">indirect2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">type_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">type_</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>需要注意的是， <code class="docutils literal notranslate"><span class="pre">indirect1/2</span></code> 均被初始化为 0 。因为最开始文件内容的大小为 0 字节，并不会用到一级/二级索引。为了节约空间，内核会按需分配一级/二级索引块。此外，直接索引 <code class="docutils literal notranslate"><span class="pre">direct</span></code> 也被清零。</p>
<p><code class="docutils literal notranslate"><span class="pre">is_file</span></code> 和 <code class="docutils literal notranslate"><span class="pre">is_dir</span></code> 两个方法可以用来确认 <code class="docutils literal notranslate"><span class="pre">DiskInode</span></code> 的类型为文件还是目录：</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// easy-fs/src/layout.rs</span>

<span class="k">impl</span><span class="w"> </span><span class="n">DiskInode</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">is_dir</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">type_</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">DiskInodeType</span>::<span class="n">Directory</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">is_file</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">type_</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">DiskInodeType</span>::<span class="n">File</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">get_block_id</span></code> 方法体现了 <code class="docutils literal notranslate"><span class="pre">DiskInode</span></code> 最重要的数据块索引功能，它可以从索引中查到它自身用于保存文件内容的第 <code class="docutils literal notranslate"><span class="pre">block_id</span></code> 个数据块的块编号，这样后续才能对这个数据块进行访问：</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="c1">// easy-fs/src/layout.rs</span>
<span class="linenos"> 2</span>
<span class="linenos"> 3</span><span class="k">const</span><span class="w"> </span><span class="n">INODE_INDIRECT1_COUNT</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="n">BLOCK_SZ</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="linenos"> 4</span><span class="k">const</span><span class="w"> </span><span class="n">INDIRECT1_BOUND</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="n">DIRECT_BOUND</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">INODE_INDIRECT1_COUNT</span><span class="p">;</span>
<span class="linenos"> 5</span><span class="k">type</span> <span class="nc">IndirectBlock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="kt">u32</span><span class="p">;</span><span class="w"> </span><span class="n">BLOCK_SZ</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">4</span><span class="p">];</span>
<span class="linenos"> 6</span>
<span class="linenos"> 7</span><span class="k">impl</span><span class="w"> </span><span class="n">DiskInode</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 8</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">get_block_id</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">inner_id</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">block_device</span>: <span class="kp">&amp;</span><span class="nc">Arc</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">BlockDevice</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span>
<span class="linenos"> 9</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">inner_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inner_id</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">;</span>
<span class="hll"><span class="linenos">10</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">inner_id</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">INODE_DIRECT_COUNT</span><span class="w"> </span><span class="p">{</span>
</span><span class="linenos">11</span><span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">direct</span><span class="p">[</span><span class="n">inner_id</span><span class="p">]</span>
<span class="hll"><span class="linenos">12</span><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">inner_id</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">INDIRECT1_BOUND</span><span class="w"> </span><span class="p">{</span>
</span><span class="linenos">13</span><span class="w">            </span><span class="n">get_block_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">indirect1</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">Arc</span>::<span class="n">clone</span><span class="p">(</span><span class="n">block_device</span><span class="p">))</span>
<span class="linenos">14</span><span class="w">                </span><span class="p">.</span><span class="n">lock</span><span class="p">()</span>
<span class="linenos">15</span><span class="w">                </span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">indirect_block</span>: <span class="kp">&amp;</span><span class="nc">IndirectBlock</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">16</span><span class="w">                    </span><span class="n">indirect_block</span><span class="p">[</span><span class="n">inner_id</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">INODE_DIRECT_COUNT</span><span class="p">]</span>
<span class="linenos">17</span><span class="w">                </span><span class="p">})</span>
<span class="hll"><span class="linenos">18</span><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
</span><span class="linenos">19</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">last</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inner_id</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">INDIRECT1_BOUND</span><span class="p">;</span>
<span class="linenos">20</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">indirect1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_block_cache</span><span class="p">(</span>
<span class="linenos">21</span><span class="w">                </span><span class="bp">self</span><span class="p">.</span><span class="n">indirect2</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span>
<span class="linenos">22</span><span class="w">                </span><span class="n">Arc</span>::<span class="n">clone</span><span class="p">(</span><span class="n">block_device</span><span class="p">)</span>
<span class="linenos">23</span><span class="w">            </span><span class="p">)</span>
<span class="linenos">24</span><span class="w">            </span><span class="p">.</span><span class="n">lock</span><span class="p">()</span>
<span class="linenos">25</span><span class="w">            </span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">indirect2</span>: <span class="kp">&amp;</span><span class="nc">IndirectBlock</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">26</span><span class="w">                </span><span class="n">indirect2</span><span class="p">[</span><span class="n">last</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">INODE_INDIRECT1_COUNT</span><span class="p">]</span>
<span class="linenos">27</span><span class="w">            </span><span class="p">});</span>
<span class="linenos">28</span><span class="w">            </span><span class="n">get_block_cache</span><span class="p">(</span>
<span class="linenos">29</span><span class="w">                </span><span class="n">indirect1</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span>
<span class="linenos">30</span><span class="w">                </span><span class="n">Arc</span>::<span class="n">clone</span><span class="p">(</span><span class="n">block_device</span><span class="p">)</span>
<span class="linenos">31</span><span class="w">            </span><span class="p">)</span>
<span class="linenos">32</span><span class="w">            </span><span class="p">.</span><span class="n">lock</span><span class="p">()</span>
<span class="linenos">33</span><span class="w">            </span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">indirect1</span>: <span class="kp">&amp;</span><span class="nc">IndirectBlock</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">34</span><span class="w">                </span><span class="n">indirect1</span><span class="p">[</span><span class="n">last</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">INODE_INDIRECT1_COUNT</span><span class="p">]</span>
<span class="linenos">35</span><span class="w">            </span><span class="p">})</span>
<span class="linenos">36</span><span class="w">        </span><span class="p">}</span>
<span class="linenos">37</span><span class="w">    </span><span class="p">}</span>
<span class="linenos">38</span><span class="p">}</span>
</pre></div>
</div>
<p>这里需要说明的是：</p>
<ul class="simple">
<li><p>第 10/12/18 行分别利用直接索引/一级索引和二级索引，具体选用哪种索引方式取决于 <code class="docutils literal notranslate"><span class="pre">block_id</span></code> 所在的区间。</p></li>
<li><p>在对一个索引块进行操作的时候，我们将其解析为磁盘数据结构 <code class="docutils literal notranslate"><span class="pre">IndirectBlock</span></code> ，实质上就是一个 <code class="docutils literal notranslate"><span class="pre">u32</span></code> 数组，每个都指向一个下一级索引块或者数据块。</p></li>
<li><p>对于二级索引的情况，需要先查二级索引块找到挂在它下面的一级索引块，再通过一级索引块找到数据块。</p></li>
</ul>
<p>在对文件/目录初始化之后，它的 <code class="docutils literal notranslate"><span class="pre">size</span></code> 均为 0 ，此时并不会索引到任何数据块。它需要通过 <code class="docutils literal notranslate"><span class="pre">increase_size</span></code> 方法逐步扩充容量。在扩充的时候，自然需要一些新的数据块来作为索引块或是保存内容的数据块。我们需要先编写一些辅助方法来确定在容量扩充的时候额外需要多少块：</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// easy-fs/src/layout.rs</span>

<span class="k">impl</span><span class="w"> </span><span class="n">DiskInode</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="sd">/// Return block number correspond to size.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">data_blocks</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span>
<span class="w">        </span><span class="bp">Self</span>::<span class="n">_data_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">size</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">_data_blocks</span><span class="p">(</span><span class="n">size</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span>
<span class="w">        </span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">BLOCK_SZ</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">BLOCK_SZ</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="sd">/// Return number of blocks needed include indirect1/2.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">total_blocks</span><span class="p">(</span><span class="n">size</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">data_blocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">Self</span>::<span class="n">_data_blocks</span><span class="p">(</span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">;</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">total</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data_blocks</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">;</span>
<span class="w">        </span><span class="c1">// indirect1</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">data_blocks</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">INODE_DIRECT_COUNT</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">total</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="c1">// indirect2</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">data_blocks</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">INDIRECT1_BOUND</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">total</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">            </span><span class="c1">// sub indirect1</span>
<span class="w">            </span><span class="n">total</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="p">(</span><span class="n">data_blocks</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">INDIRECT1_BOUND</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">INODE_INDIRECT1_COUNT</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">INODE_INDIRECT1_COUNT</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">total</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">blocks_num_needed</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">new_size</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span>
<span class="w">        </span><span class="fm">assert!</span><span class="p">(</span><span class="n">new_size</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
<span class="w">        </span><span class="bp">Self</span>::<span class="n">total_blocks</span><span class="p">(</span><span class="n">new_size</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="bp">Self</span>::<span class="n">total_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">size</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">data_blocks</span></code> 方法可以计算为了容纳自身 <code class="docutils literal notranslate"><span class="pre">size</span></code> 字节的内容需要多少个数据块。计算的过程只需用 <code class="docutils literal notranslate"><span class="pre">size</span></code> 除以每个块的大小 <code class="docutils literal notranslate"><span class="pre">BLOCK_SZ</span></code> 并向上取整。而 <code class="docutils literal notranslate"><span class="pre">total_blocks</span></code> 不仅包含数据块，还需要统计索引块。计算的方法也很简单，先调用 <code class="docutils literal notranslate"><span class="pre">data_blocks</span></code> 得到需要多少数据块，再根据数据块数目所处的区间统计索引块即可。 <code class="docutils literal notranslate"><span class="pre">blocks_num_needed</span></code> 可以计算将一个 <code class="docutils literal notranslate"><span class="pre">DiskInode</span></code> 的 <code class="docutils literal notranslate"><span class="pre">size</span></code> 扩容到 <code class="docutils literal notranslate"><span class="pre">new_size</span></code> 需要额外多少个数据和索引块。这只需要调用两次 <code class="docutils literal notranslate"><span class="pre">total_blocks</span></code> 作差即可。</p>
<p>下面给出 <code class="docutils literal notranslate"><span class="pre">increase_size</span></code> 方法的接口：</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// easy-fs/src/layout.rs</span>

<span class="k">impl</span><span class="w"> </span><span class="n">DiskInode</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">increase_size</span><span class="p">(</span>
<span class="w">        </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span>
<span class="w">        </span><span class="n">new_size</span>: <span class="kt">u32</span><span class="p">,</span>
<span class="w">        </span><span class="n">new_blocks</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">        </span><span class="n">block_device</span>: <span class="kp">&amp;</span><span class="nc">Arc</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">BlockDevice</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">    </span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>其中 <code class="docutils literal notranslate"><span class="pre">new_size</span></code> 表示容量扩充之后的文件大小； <code class="docutils literal notranslate"><span class="pre">new_blocks</span></code> 是一个保存了本次容量扩充所需块编号的向量，这些块都是由上层的磁盘块管理器负责分配的。 <code class="docutils literal notranslate"><span class="pre">increase_size</span></code> 的实现有些复杂，在这里不详细介绍。大致的思路是按照直接索引、一级索引再到二级索引的顺序进行扩充。</p>
<p>有些时候我们还需要清空文件的内容并回收所有数据和索引块。这是通过 <code class="docutils literal notranslate"><span class="pre">clear_size</span></code> 方法来实现的：</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// easy-fs/src/layout.rs</span>

<span class="k">impl</span><span class="w"> </span><span class="n">DiskInode</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="sd">/// Clear size to zero and return blocks that should be deallocated.</span>
<span class="w">    </span><span class="sd">///</span>
<span class="w">    </span><span class="sd">/// We will clear the block contents to zero later.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">clear_size</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">block_device</span>: <span class="kp">&amp;</span><span class="nc">Arc</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">BlockDevice</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>它会将回收的所有块的编号保存在一个向量中返回给磁盘块管理器。它的实现原理和 <code class="docutils literal notranslate"><span class="pre">increase_size</span></code> 一样也分为多个阶段，在这里不展开。</p>
<p>接下来需要考虑通过 <code class="docutils literal notranslate"><span class="pre">DiskInode</span></code> 来读写它索引的那些数据块中的数据。这些数据可以被视为一个字节序列，而每次都是选取其中的一段连续区间进行操作，以 <code class="docutils literal notranslate"><span class="pre">read_at</span></code> 为例：</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="c1">// easy-fs/src/layout.rs</span>
<span class="linenos"> 2</span>
<span class="linenos"> 3</span><span class="k">type</span> <span class="nc">DataBlock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">;</span><span class="w"> </span><span class="n">BLOCK_SZ</span><span class="p">];</span>
<span class="linenos"> 4</span>
<span class="linenos"> 5</span><span class="k">impl</span><span class="w"> </span><span class="n">DiskInode</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 6</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">read_at</span><span class="p">(</span>
<span class="linenos"> 7</span><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span>
<span class="linenos"> 8</span><span class="w">        </span><span class="n">offset</span>: <span class="kt">usize</span><span class="p">,</span>
<span class="linenos"> 9</span><span class="w">        </span><span class="n">buf</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">],</span>
<span class="linenos">10</span><span class="w">        </span><span class="n">block_device</span>: <span class="kp">&amp;</span><span class="nc">Arc</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">BlockDevice</span><span class="o">&gt;</span><span class="p">,</span>
<span class="linenos">11</span><span class="w">    </span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span> <span class="p">{</span>
<span class="linenos">12</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">offset</span><span class="p">;</span>
<span class="linenos">13</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">buf</span><span class="p">.</span><span class="n">len</span><span class="p">()).</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">);</span>
<span class="linenos">14</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">15</span><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="linenos">16</span><span class="w">        </span><span class="p">}</span>
<span class="linenos">17</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">start_block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">BLOCK_SZ</span><span class="p">;</span>
<span class="linenos">18</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">read_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="k">usize</span><span class="p">;</span>
<span class="linenos">19</span><span class="w">        </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">20</span><span class="w">            </span><span class="c1">// calculate end of current block</span>
<span class="linenos">21</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">end_current_block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">start</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">BLOCK_SZ</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">BLOCK_SZ</span><span class="p">;</span>
<span class="linenos">22</span><span class="w">            </span><span class="n">end_current_block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">end_current_block</span><span class="p">.</span><span class="n">min</span><span class="p">(</span><span class="n">end</span><span class="p">);</span>
<span class="linenos">23</span><span class="w">            </span><span class="c1">// read and update read size</span>
<span class="linenos">24</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">block_read_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">end_current_block</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start</span><span class="p">;</span>
<span class="linenos">25</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">dst</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">buf</span><span class="p">[</span><span class="n">read_size</span><span class="o">..</span><span class="n">read_size</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">block_read_size</span><span class="p">];</span>
<span class="linenos">26</span><span class="w">            </span><span class="n">get_block_cache</span><span class="p">(</span>
<span class="linenos">27</span><span class="w">                </span><span class="bp">self</span><span class="p">.</span><span class="n">get_block_id</span><span class="p">(</span><span class="n">start_block</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">block_device</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span>
<span class="linenos">28</span><span class="w">                </span><span class="n">Arc</span>::<span class="n">clone</span><span class="p">(</span><span class="n">block_device</span><span class="p">),</span>
<span class="linenos">29</span><span class="w">            </span><span class="p">)</span>
<span class="linenos">30</span><span class="w">            </span><span class="p">.</span><span class="n">lock</span><span class="p">()</span>
<span class="linenos">31</span><span class="w">            </span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">data_block</span>: <span class="kp">&amp;</span><span class="nc">DataBlock</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">32</span><span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">src</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">data_block</span><span class="p">[</span><span class="n">start</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">BLOCK_SZ</span><span class="o">..</span><span class="n">start</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">BLOCK_SZ</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">block_read_size</span><span class="p">];</span>
<span class="linenos">33</span><span class="w">                </span><span class="n">dst</span><span class="p">.</span><span class="n">copy_from_slice</span><span class="p">(</span><span class="n">src</span><span class="p">);</span>
<span class="linenos">34</span><span class="w">            </span><span class="p">});</span>
<span class="linenos">35</span><span class="w">            </span><span class="n">read_size</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">block_read_size</span><span class="p">;</span>
<span class="linenos">36</span><span class="w">            </span><span class="c1">// move to next block</span>
<span class="linenos">37</span><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">end_current_block</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="linenos">38</span><span class="w">            </span><span class="n">start_block</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="linenos">39</span><span class="w">            </span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">end_current_block</span><span class="p">;</span>
<span class="linenos">40</span><span class="w">        </span><span class="p">}</span>
<span class="linenos">41</span><span class="w">        </span><span class="n">read_size</span>
<span class="linenos">42</span><span class="w">    </span><span class="p">}</span>
<span class="linenos">43</span><span class="p">}</span>
</pre></div>
</div>
<p>它的含义是：将文件内容从 <code class="docutils literal notranslate"><span class="pre">offset</span></code> 字节开始的部分读到内存中的缓冲区 <code class="docutils literal notranslate"><span class="pre">buf</span></code> 中，并返回实际读到的字节数。如果文件剩下的内容还足够多，那么缓冲区会被填满；否则文件剩下的全部内容都会被读到缓冲区中。具体实现上有很多细节，但大致的思路是遍历位于字节区间 <code class="docutils literal notranslate"><span class="pre">start,end</span></code> 中间的那些块，将它们视为一个 <code class="docutils literal notranslate"><span class="pre">DataBlock</span></code> （也就是一个字节数组），并将其中的部分内容复制到缓冲区 <code class="docutils literal notranslate"><span class="pre">buf</span></code> 中适当的区域。 <code class="docutils literal notranslate"><span class="pre">start_block</span></code> 维护着目前是文件内部第多少个数据块，需要首先调用 <code class="docutils literal notranslate"><span class="pre">get_block_id</span></code> 从索引中查到这个数据块在块设备中的块编号，随后才能传入 <code class="docutils literal notranslate"><span class="pre">get_block_cache</span></code> 中将正确的数据块缓存到内存中进行访问。</p>
<p>在第 14 行进行了简单的边界条件判断，如果要读取的内容超出了文件的范围，那么直接返回 0 ，表示读取不到任何内容。</p>
<p><code class="docutils literal notranslate"><span class="pre">write_at</span></code> 的实现思路基本上和 <code class="docutils literal notranslate"><span class="pre">read_at</span></code> 完全相同。但不同的是 <code class="docutils literal notranslate"><span class="pre">write_at</span></code> 不会出现失败的情况；只要 Inode 管理的数据块的大小足够，传入的整个缓冲区的数据都必定会被写入到文件中。当从 <code class="docutils literal notranslate"><span class="pre">offset</span></code> 开始的区间超出了文件范围的时候，就需要调用者在调用 <code class="docutils literal notranslate"><span class="pre">write_at</span></code> 之前提前调用 <code class="docutils literal notranslate"><span class="pre">increase_size</span></code> ，将文件大小扩充到区间的右端，保证写入的完整性。</p>
</div>
<div class="section" id="id12">
<h3>数据块与目录项<a class="headerlink" href="#id12" title="永久链接至标题">#</a></h3>
<p>作为一个文件而言，它的内容在文件系统看来没有任何既定的格式，都只是一个字节序列。因此每个保存内容的数据块都只是一个字节数组：</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// easy-fs/src/layout.rs</span>

<span class="k">type</span> <span class="nc">DataBlock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">;</span><span class="w"> </span><span class="n">BLOCK_SZ</span><span class="p">];</span>
</pre></div>
</div>
<p>然而，目录的内容却需要遵从一种特殊的格式。在我们的实现中，它可以看成一个目录项的序列，每个目录项都是一个二元组，二元组的首个元素是目录下面的一个文件（或子目录）的文件名（或目录名），另一个元素则是文件（或子目录）所在的索引节点编号。目录项相当于目录树结构上的子树节点，我们需要通过它来一级一级的找到实际要访问的文件或目录。目录项 <code class="docutils literal notranslate"><span class="pre">DirEntry</span></code> 的定义如下：</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// easy-fs/src/layout.rs</span>

<span class="k">const</span><span class="w"> </span><span class="n">NAME_LENGTH_LIMIT</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="mi">27</span><span class="p">;</span>

<span class="cp">#[repr(C)]</span>
<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">DirEntry</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">name</span>: <span class="p">[</span><span class="kt">u8</span><span class="p">;</span><span class="w"> </span><span class="n">NAME_LENGTH_LIMIT</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">],</span>
<span class="w">    </span><span class="n">inode_number</span>: <span class="kt">u32</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">pub</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">DIRENT_SZ</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span>
</pre></div>
</div>
<p>目录项 <code class="docutils literal notranslate"><span class="pre">Dirent</span></code> 最大允许保存长度为 27 的文件/目录名（数组 <code class="docutils literal notranslate"><span class="pre">name</span></code> 中最末的一个字节留给 <code class="docutils literal notranslate"><span class="pre">\0</span></code> ），且它自身占据空间 32 字节，每个数据块可以存储 16 个目录项。我们可以通过 <code class="docutils literal notranslate"><span class="pre">empty</span></code> 和 <code class="docutils literal notranslate"><span class="pre">new</span></code> 分别生成一个空的目录项或是一个合法的目录项：</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// easy-fs/src/layout.rs</span>

<span class="k">impl</span><span class="w"> </span><span class="n">DirEntry</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">empty</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">name</span>: <span class="p">[</span><span class="mi">0</span><span class="k">u8</span><span class="p">;</span><span class="w"> </span><span class="n">NAME_LENGTH_LIMIT</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">],</span>
<span class="w">            </span><span class="n">inode_number</span>: <span class="mi">0</span><span class="p">,</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">name</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">inode_number</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">bytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="k">u8</span><span class="p">;</span><span class="w"> </span><span class="n">NAME_LENGTH_LIMIT</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span>
<span class="w">        </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">bytes</span><span class="p">[</span><span class="o">..</span><span class="n">name</span><span class="p">.</span><span class="n">len</span><span class="p">()].</span><span class="n">copy_from_slice</span><span class="p">(</span><span class="n">name</span><span class="p">.</span><span class="n">as_bytes</span><span class="p">());</span>
<span class="w">        </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">name</span>: <span class="nc">bytes</span><span class="p">,</span>
<span class="w">            </span><span class="n">inode_number</span><span class="p">,</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在从目录的内容中读取目录项或者是将目录项写入目录的时候，我们需要将目录项转化为缓冲区（即字节切片）的形式来符合索引节点 <code class="docutils literal notranslate"><span class="pre">Inode</span></code>  数据结构中的 <code class="docutils literal notranslate"><span class="pre">read_at</span></code> 或 <code class="docutils literal notranslate"><span class="pre">write_at</span></code> 方法接口的要求：</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// easy-fs/src/layout.rs</span>

<span class="k">impl</span><span class="w"> </span><span class="n">DirEntry</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">as_bytes</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">core</span>::<span class="n">slice</span>::<span class="n">from_raw_parts</span><span class="p">(</span>
<span class="w">                </span><span class="bp">self</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span>
<span class="w">                </span><span class="n">DIRENT_SZ</span><span class="p">,</span>
<span class="w">            </span><span class="p">)</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">as_bytes_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">core</span>::<span class="n">slice</span>::<span class="n">from_raw_parts_mut</span><span class="p">(</span>
<span class="w">                </span><span class="bp">self</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span>
<span class="w">                </span><span class="n">DIRENT_SZ</span><span class="p">,</span>
<span class="w">            </span><span class="p">)</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>此外，通过 <code class="docutils literal notranslate"><span class="pre">name</span></code> 和 <code class="docutils literal notranslate"><span class="pre">inode_number</span></code> 方法可以取出目录项中的内容：</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// easy-fs/src/layout.rs</span>

<span class="k">impl</span><span class="w"> </span><span class="n">DirEntry</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">name</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="kt">str</span> <span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="k">usize</span><span class="o">..</span><span class="p">).</span><span class="n">find</span><span class="p">(</span><span class="o">|</span><span class="n">i</span><span class="o">|</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">name</span><span class="p">[</span><span class="o">*</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">        </span><span class="n">core</span>::<span class="kt">str</span>::<span class="n">from_utf8</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">name</span><span class="p">[</span><span class="o">..</span><span class="n">len</span><span class="p">]).</span><span class="n">unwrap</span><span class="p">()</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">inode_number</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">inode_number</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id13">
<h2>磁盘块管理器<a class="headerlink" href="#id13" title="永久链接至标题">#</a></h2>
<p>本层的代码在 <code class="docutils literal notranslate"><span class="pre">efs.rs</span></code> 中。
上面介绍了 easy-fs 的磁盘布局设计以及数据的组织方式 – 即各类磁盘数据结构。但是它们都是以比较零散的形式分开介绍的，并没有体现出磁盘布局上各个区域是如何划分的。实现 easy-fs 的整体磁盘布局，将各段区域及上面的磁盘数据结构结构整合起来就是简易文件系统 <code class="docutils literal notranslate"><span class="pre">EasyFileSystem</span></code> 的职责。它知道每个布局区域所在的位置，磁盘块的分配和回收也需要经过它才能完成，因此某种意义上讲它还可以看成一个磁盘块管理器。</p>
<p>注意从这一层开始，所有的数据结构就都放在内存上了。</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// easy-fs/src/efs.rs</span>

<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">EasyFileSystem</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">block_device</span>: <span class="nc">Arc</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">BlockDevice</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">inode_bitmap</span>: <span class="nc">Bitmap</span><span class="p">,</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">data_bitmap</span>: <span class="nc">Bitmap</span><span class="p">,</span>
<span class="w">    </span><span class="n">inode_area_start_block</span>: <span class="kt">u32</span><span class="p">,</span>
<span class="w">    </span><span class="n">data_area_start_block</span>: <span class="kt">u32</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">EasyFileSystem</span></code> 包含索引节点和数据块的两个位图 <code class="docutils literal notranslate"><span class="pre">inode_bitmap</span></code> 和 <code class="docutils literal notranslate"><span class="pre">data_bitmap</span></code> ，还记录下索引节点区域和数据块区域起始块编号方便确定每个索引节点和数据块在磁盘上的具体位置。我们还要在其中保留块设备的一个指针 <code class="docutils literal notranslate"><span class="pre">block_device</span></code> ，在进行后续操作的时候，该指针会被拷贝并传递给下层的数据结构，让它们也能够直接访问块设备。</p>
<p>通过 <code class="docutils literal notranslate"><span class="pre">create</span></code> 方法可以在块设备上创建并初始化一个 easy-fs 文件系统：</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="c1">// easy-fs/src/efs.rs</span>
<span class="linenos"> 2</span>
<span class="linenos"> 3</span><span class="k">impl</span><span class="w"> </span><span class="n">EasyFileSystem</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 4</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">create</span><span class="p">(</span>
<span class="linenos"> 5</span><span class="w">        </span><span class="n">block_device</span>: <span class="nc">Arc</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">BlockDevice</span><span class="o">&gt;</span><span class="p">,</span>
<span class="linenos"> 6</span><span class="w">        </span><span class="n">total_blocks</span>: <span class="kt">u32</span><span class="p">,</span>
<span class="linenos"> 7</span><span class="w">        </span><span class="n">inode_bitmap_blocks</span>: <span class="kt">u32</span><span class="p">,</span>
<span class="linenos"> 8</span><span class="w">    </span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Arc</span><span class="o">&lt;</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="bp">Self</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 9</span><span class="w">        </span><span class="c1">// calculate block size of areas &amp; create bitmaps</span>
<span class="linenos">10</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">inode_bitmap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Bitmap</span>::<span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">inode_bitmap_blocks</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">);</span>
<span class="linenos">11</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">inode_num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inode_bitmap</span><span class="p">.</span><span class="n">maximum</span><span class="p">();</span>
<span class="linenos">12</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">inode_area_blocks</span><span class="w"> </span><span class="o">=</span>
<span class="linenos">13</span><span class="w">            </span><span class="p">((</span><span class="n">inode_num</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">core</span>::<span class="n">mem</span>::<span class="n">size_of</span>::<span class="o">&lt;</span><span class="n">DiskInode</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">BLOCK_SZ</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">BLOCK_SZ</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">;</span>
<span class="linenos">14</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">inode_total_blocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inode_bitmap_blocks</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">inode_area_blocks</span><span class="p">;</span>
<span class="linenos">15</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">data_total_blocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">total_blocks</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">inode_total_blocks</span><span class="p">;</span>
<span class="linenos">16</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">data_bitmap_blocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">data_total_blocks</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4096</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">4097</span><span class="p">;</span>
<span class="linenos">17</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">data_area_blocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data_total_blocks</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">data_bitmap_blocks</span><span class="p">;</span>
<span class="linenos">18</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">data_bitmap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Bitmap</span>::<span class="n">new</span><span class="p">(</span>
<span class="linenos">19</span><span class="w">            </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">inode_bitmap_blocks</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">inode_area_blocks</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span>
<span class="linenos">20</span><span class="w">            </span><span class="n">data_bitmap_blocks</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span>
<span class="linenos">21</span><span class="w">        </span><span class="p">);</span>
<span class="linenos">22</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">efs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">23</span><span class="w">            </span><span class="n">block_device</span>: <span class="nc">Arc</span>::<span class="n">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_device</span><span class="p">),</span>
<span class="linenos">24</span><span class="w">            </span><span class="n">inode_bitmap</span><span class="p">,</span>
<span class="linenos">25</span><span class="w">            </span><span class="n">data_bitmap</span><span class="p">,</span>
<span class="linenos">26</span><span class="w">            </span><span class="n">inode_area_start_block</span>: <span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">inode_bitmap_blocks</span><span class="p">,</span>
<span class="linenos">27</span><span class="w">            </span><span class="n">data_area_start_block</span>: <span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">inode_total_blocks</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">data_bitmap_blocks</span><span class="p">,</span>
<span class="linenos">28</span><span class="w">        </span><span class="p">};</span>
<span class="linenos">29</span><span class="w">        </span><span class="c1">// clear all blocks</span>
<span class="linenos">30</span><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="n">total_blocks</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">31</span><span class="w">            </span><span class="n">get_block_cache</span><span class="p">(</span>
<span class="linenos">32</span><span class="w">                </span><span class="n">i</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span>
<span class="linenos">33</span><span class="w">                </span><span class="n">Arc</span>::<span class="n">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_device</span><span class="p">)</span>
<span class="linenos">34</span><span class="w">            </span><span class="p">)</span>
<span class="linenos">35</span><span class="w">            </span><span class="p">.</span><span class="n">lock</span><span class="p">()</span>
<span class="linenos">36</span><span class="w">            </span><span class="p">.</span><span class="n">modify</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">data_block</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">DataBlock</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">37</span><span class="w">                </span><span class="k">for</span><span class="w"> </span><span class="n">byte</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">data_block</span><span class="p">.</span><span class="n">iter_mut</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">*</span><span class="n">byte</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="linenos">38</span><span class="w">            </span><span class="p">});</span>
<span class="linenos">39</span><span class="w">        </span><span class="p">}</span>
<span class="linenos">40</span><span class="w">        </span><span class="c1">// initialize SuperBlock</span>
<span class="linenos">41</span><span class="w">        </span><span class="n">get_block_cache</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">Arc</span>::<span class="n">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_device</span><span class="p">))</span>
<span class="linenos">42</span><span class="w">        </span><span class="p">.</span><span class="n">lock</span><span class="p">()</span>
<span class="linenos">43</span><span class="w">        </span><span class="p">.</span><span class="n">modify</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">super_block</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">SuperBlock</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">44</span><span class="w">            </span><span class="n">super_block</span><span class="p">.</span><span class="n">initialize</span><span class="p">(</span>
<span class="linenos">45</span><span class="w">                </span><span class="n">total_blocks</span><span class="p">,</span>
<span class="linenos">46</span><span class="w">                </span><span class="n">inode_bitmap_blocks</span><span class="p">,</span>
<span class="linenos">47</span><span class="w">                </span><span class="n">inode_area_blocks</span><span class="p">,</span>
<span class="linenos">48</span><span class="w">                </span><span class="n">data_bitmap_blocks</span><span class="p">,</span>
<span class="linenos">49</span><span class="w">                </span><span class="n">data_area_blocks</span><span class="p">,</span>
<span class="linenos">50</span><span class="w">            </span><span class="p">);</span>
<span class="linenos">51</span><span class="w">        </span><span class="p">});</span>
<span class="linenos">52</span><span class="w">        </span><span class="c1">// write back immediately</span>
<span class="linenos">53</span><span class="w">        </span><span class="c1">// create a inode for root node &quot;/&quot;</span>
<span class="linenos">54</span><span class="w">        </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">efs</span><span class="p">.</span><span class="n">alloc_inode</span><span class="p">(),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="linenos">55</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">root_inode_block_id</span><span class="p">,</span><span class="w"> </span><span class="n">root_inode_offset</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">efs</span><span class="p">.</span><span class="n">get_disk_inode_pos</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="linenos">56</span><span class="w">        </span><span class="n">get_block_cache</span><span class="p">(</span>
<span class="linenos">57</span><span class="w">            </span><span class="n">root_inode_block_id</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span>
<span class="linenos">58</span><span class="w">            </span><span class="n">Arc</span>::<span class="n">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_device</span><span class="p">)</span>
<span class="linenos">59</span><span class="w">        </span><span class="p">)</span>
<span class="linenos">60</span><span class="w">        </span><span class="p">.</span><span class="n">lock</span><span class="p">()</span>
<span class="linenos">61</span><span class="w">        </span><span class="p">.</span><span class="n">modify</span><span class="p">(</span><span class="n">root_inode_offset</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">disk_inode</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">DiskInode</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">62</span><span class="w">            </span><span class="n">disk_inode</span><span class="p">.</span><span class="n">initialize</span><span class="p">(</span><span class="n">DiskInodeType</span>::<span class="n">Directory</span><span class="p">);</span>
<span class="linenos">63</span><span class="w">        </span><span class="p">});</span>
<span class="linenos">64</span><span class="w">        </span><span class="n">Arc</span>::<span class="n">new</span><span class="p">(</span><span class="n">Mutex</span>::<span class="n">new</span><span class="p">(</span><span class="n">efs</span><span class="p">))</span>
<span class="linenos">65</span><span class="w">    </span><span class="p">}</span>
<span class="linenos">66</span><span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>第 10~21 行根据传入的参数计算每个区域各应该包含多少块。根据 inode 位图的大小计算 inode 区域至少需要多少个块才能够使得 inode 位图中的每个bit都能够有一个实际的 inode 可以对应，这样就确定了 inode 位图区域和 inode 区域的大小。剩下的块都分配给数据块位图区域和数据块区域。我们希望数据块位图中的每个bit仍然能够对应到一个数据块，但是数据块位图又不能过小，不然会造成某些数据块永远不会被使用。因此数据块位图区域最合理的大小是剩余的块数除以 4097 再上取整，因为位图中的每个块能够对应 4096 个数据块。其余的块就都作为数据块使用。</p></li>
<li><p>第 22 行创建 <code class="docutils literal notranslate"><span class="pre">EasyFileSystem</span></code> 实例 <code class="docutils literal notranslate"><span class="pre">efs</span></code> 。</p></li>
<li><p>第 30 行首先将块设备的前 <code class="docutils literal notranslate"><span class="pre">total_blocks</span></code> 个块清零，因为 easy-fs 要用到它们，这也是为初始化做准备。</p></li>
<li><p>第 41 行将位于块设备编号为 0 块上的超级块进行初始化，只需传入之前计算得到的每个区域的块数就行了。</p></li>
<li><p>第 54~63 行创建根目录 <code class="docutils literal notranslate"><span class="pre">/</span></code> 。首先需要调用 <code class="docutils literal notranslate"><span class="pre">alloc_inode</span></code> 在 inode 位图中分配一个 inode ，由于这是第一次分配，它的编号固定是 0 。接下来需要将分配到的 inode 初始化为 easy-fs 中的唯一一个目录，故需要调用 <code class="docutils literal notranslate"><span class="pre">get_disk_inode_pos</span></code> 来根据 inode 编号获取该 inode 所在的块的编号以及块内偏移，之后就可以将它们传给 <code class="docutils literal notranslate"><span class="pre">get_block_cache</span></code> 和 <code class="docutils literal notranslate"><span class="pre">modify</span></code> 了。</p></li>
</ul>
<p>通过 <code class="docutils literal notranslate"><span class="pre">open</span></code> 方法可以从一个已写入了 easy-fs 镜像的块设备上打开我们的 easy-fs ：</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// easy-fs/src/efs.rs</span>

<span class="k">impl</span><span class="w"> </span><span class="n">EasyFileSystem</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">open</span><span class="p">(</span><span class="n">block_device</span>: <span class="nc">Arc</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">BlockDevice</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Arc</span><span class="o">&lt;</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="bp">Self</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// read SuperBlock</span>
<span class="w">        </span><span class="n">get_block_cache</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">Arc</span>::<span class="n">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_device</span><span class="p">))</span>
<span class="w">            </span><span class="p">.</span><span class="n">lock</span><span class="p">()</span>
<span class="w">            </span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">super_block</span>: <span class="kp">&amp;</span><span class="nc">SuperBlock</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="fm">assert!</span><span class="p">(</span><span class="n">super_block</span><span class="p">.</span><span class="n">is_valid</span><span class="p">(),</span><span class="w"> </span><span class="s">&quot;Error loading EFS!&quot;</span><span class="p">);</span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">inode_total_blocks</span><span class="w"> </span><span class="o">=</span>
<span class="w">                    </span><span class="n">super_block</span><span class="p">.</span><span class="n">inode_bitmap_blocks</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">super_block</span><span class="p">.</span><span class="n">inode_area_blocks</span><span class="p">;</span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">efs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="n">block_device</span><span class="p">,</span>
<span class="w">                    </span><span class="n">inode_bitmap</span>: <span class="nc">Bitmap</span>::<span class="n">new</span><span class="p">(</span>
<span class="w">                        </span><span class="mi">1</span><span class="p">,</span>
<span class="w">                        </span><span class="n">super_block</span><span class="p">.</span><span class="n">inode_bitmap_blocks</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span>
<span class="w">                    </span><span class="p">),</span>
<span class="w">                    </span><span class="n">data_bitmap</span>: <span class="nc">Bitmap</span>::<span class="n">new</span><span class="p">(</span>
<span class="w">                        </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">inode_total_blocks</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span>
<span class="w">                        </span><span class="n">super_block</span><span class="p">.</span><span class="n">data_bitmap_blocks</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span>
<span class="w">                    </span><span class="p">),</span>
<span class="w">                    </span><span class="n">inode_area_start_block</span>: <span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">super_block</span><span class="p">.</span><span class="n">inode_bitmap_blocks</span><span class="p">,</span>
<span class="w">                    </span><span class="n">data_area_start_block</span>: <span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">inode_total_blocks</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">super_block</span><span class="p">.</span><span class="n">data_bitmap_blocks</span><span class="p">,</span>
<span class="w">                </span><span class="p">};</span>
<span class="w">                </span><span class="n">Arc</span>::<span class="n">new</span><span class="p">(</span><span class="n">Mutex</span>::<span class="n">new</span><span class="p">(</span><span class="n">efs</span><span class="p">))</span>
<span class="w">            </span><span class="p">})</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>它只需将块设备编号为 0 的块作为超级块读取进来，就可以从中知道 easy-fs 的磁盘布局，由此可以构造 <code class="docutils literal notranslate"><span class="pre">efs</span></code> 实例。</p>
<p><code class="docutils literal notranslate"><span class="pre">EasyFileSystem</span></code> 知道整个磁盘布局，即可以从 inode位图 或数据块位图上分配的 bit 编号，来算出各个存储inode和数据块的磁盘块在磁盘上的实际位置。</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// easy-fs/src/efs.rs</span>

<span class="k">impl</span><span class="w"> </span><span class="n">EasyFileSystem</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">get_disk_inode_pos</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">inode_id</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="p">(</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">inode_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">core</span>::<span class="n">mem</span>::<span class="n">size_of</span>::<span class="o">&lt;</span><span class="n">DiskInode</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">inodes_per_block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">BLOCK_SZ</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">inode_size</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">;</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">block_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">inode_area_start_block</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">inode_id</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">inodes_per_block</span><span class="p">;</span>
<span class="w">        </span><span class="p">(</span><span class="n">block_id</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">inode_id</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">inodes_per_block</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">inode_size</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">get_data_block_id</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">data_block_id</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">data_area_start_block</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">data_block_id</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>inode 和数据块的分配/回收也由 <code class="docutils literal notranslate"><span class="pre">EasyFileSystem</span></code> 知 负责：</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// easy-fs/src/efs.rs</span>

<span class="k">impl</span><span class="w"> </span><span class="n">EasyFileSystem</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">alloc_inode</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">inode_bitmap</span><span class="p">.</span><span class="n">alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">block_device</span><span class="p">).</span><span class="n">unwrap</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="sd">/// Return a block ID not ID in the data area.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">alloc_data</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">data_bitmap</span><span class="p">.</span><span class="n">alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">block_device</span><span class="p">).</span><span class="n">unwrap</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">data_area_start_block</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">dealloc_data</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">block_id</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">get_block_cache</span><span class="p">(</span>
<span class="w">            </span><span class="n">block_id</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span>
<span class="w">            </span><span class="n">Arc</span>::<span class="n">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">block_device</span><span class="p">)</span>
<span class="w">        </span><span class="p">)</span>
<span class="w">        </span><span class="p">.</span><span class="n">lock</span><span class="p">()</span>
<span class="w">        </span><span class="p">.</span><span class="n">modify</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">data_block</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">DataBlock</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">data_block</span><span class="p">.</span><span class="n">iter_mut</span><span class="p">().</span><span class="n">for_each</span><span class="p">(</span><span class="o">|</span><span class="n">p</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="p">})</span>
<span class="w">        </span><span class="p">});</span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">data_bitmap</span><span class="p">.</span><span class="n">dealloc</span><span class="p">(</span>
<span class="w">            </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">block_device</span><span class="p">,</span>
<span class="w">            </span><span class="p">(</span><span class="n">block_id</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">data_area_start_block</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span>
<span class="w">        </span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>注意：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">alloc_data</span></code> 和 <code class="docutils literal notranslate"><span class="pre">dealloc_data</span></code> 分配/回收数据块传入/返回的参数都表示数据块在块设备上的编号，而不是在数据块位图中分配的bit编号；</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dealloc_inode</span></code> 未实现，因为现在还不支持文件删除。</p></li>
</ul>
</div>
<div class="section" id="id14">
<h2>索引节点<a class="headerlink" href="#id14" title="永久链接至标题">#</a></h2>
<p>服务于文件相关系统调用的索引节点层的代码在 <code class="docutils literal notranslate"><span class="pre">vfs.rs</span></code> 中。</p>
<p><code class="docutils literal notranslate"><span class="pre">EasyFileSystem</span></code> 实现了磁盘布局并能够将磁盘块有效的管理起来。但是对于文件系统的使用者而言，他们往往不关心磁盘布局是如何实现的，而是更希望能够直接看到目录树结构中逻辑上的文件和目录。为此需要设计索引节点 <code class="docutils literal notranslate"><span class="pre">Inode</span></code> 暴露给文件系统的使用者，让他们能够直接对文件和目录进行操作。 <code class="docutils literal notranslate"><span class="pre">Inode</span></code> 和 <code class="docutils literal notranslate"><span class="pre">DiskInode</span></code> 的区别从它们的名字中就可以看出： <code class="docutils literal notranslate"><span class="pre">DiskInode</span></code> 放在磁盘块中比较固定的位置，而 <code class="docutils literal notranslate"><span class="pre">Inode</span></code> 是放在内存中的记录文件索引节点信息的数据结构。</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// easy-fs/src/vfs.rs</span>

<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Inode</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">block_id</span>: <span class="kt">usize</span><span class="p">,</span>
<span class="w">    </span><span class="n">block_offset</span>: <span class="kt">usize</span><span class="p">,</span>
<span class="w">    </span><span class="n">fs</span>: <span class="nc">Arc</span><span class="o">&lt;</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="n">EasyFileSystem</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="w">    </span><span class="n">block_device</span>: <span class="nc">Arc</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">BlockDevice</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">block_id</span></code> 和 <code class="docutils literal notranslate"><span class="pre">block_offset</span></code> 记录该 <code class="docutils literal notranslate"><span class="pre">Inode</span></code> 对应的 <code class="docutils literal notranslate"><span class="pre">DiskInode</span></code> 保存在磁盘上的具体位置方便我们后续对它进行访问。 <code class="docutils literal notranslate"><span class="pre">fs</span></code> 是指向 <code class="docutils literal notranslate"><span class="pre">EasyFileSystem</span></code> 的一个指针，因为对 <code class="docutils literal notranslate"><span class="pre">Inode</span></code> 的种种操作实际上都是要通过底层的文件系统来完成。</p>
<p>仿照 <code class="docutils literal notranslate"><span class="pre">BlockCache::read/modify</span></code> ，我们可以设计两个方法来简化对于 <code class="docutils literal notranslate"><span class="pre">Inode</span></code> 对应的磁盘上的 <code class="docutils literal notranslate"><span class="pre">DiskInode</span></code> 的访问流程，而不是每次都需要 <code class="docutils literal notranslate"><span class="pre">get_block_cache.lock.read/modify</span></code> ：</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// easy-fs/src/vfs.rs</span>

<span class="k">impl</span><span class="w"> </span><span class="n">Inode</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">read_disk_inode</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">impl</span><span class="w"> </span><span class="nb">FnOnce</span><span class="p">(</span><span class="o">&amp;</span><span class="n">DiskInode</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">V</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">V</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">get_block_cache</span><span class="p">(</span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">block_id</span><span class="p">,</span>
<span class="w">            </span><span class="n">Arc</span>::<span class="n">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">block_device</span><span class="p">)</span>
<span class="w">        </span><span class="p">).</span><span class="n">lock</span><span class="p">().</span><span class="n">read</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">block_offset</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">modify_disk_inode</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">impl</span><span class="w"> </span><span class="nb">FnOnce</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">DiskInode</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">V</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">V</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">get_block_cache</span><span class="p">(</span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">block_id</span><span class="p">,</span>
<span class="w">            </span><span class="n">Arc</span>::<span class="n">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">block_device</span><span class="p">)</span>
<span class="w">        </span><span class="p">).</span><span class="n">lock</span><span class="p">().</span><span class="n">modify</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">block_offset</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>下面分别介绍文件系统的使用者对于文件系统的一些常用操作：</p>
<div class="section" id="inode">
<h3>获取根目录的 inode<a class="headerlink" href="#inode" title="永久链接至标题">#</a></h3>
<p>文件系统的使用者在通过 <code class="docutils literal notranslate"><span class="pre">EasyFileSystem::open</span></code> 从装载了 easy-fs 镜像的块设备上打开 easy-fs 之后，要做的第一件事情就是获取根目录的 <code class="docutils literal notranslate"><span class="pre">Inode</span></code> 。因为 <code class="docutils literal notranslate"><span class="pre">EasyFileSystem</span></code> 目前仅支持绝对路径，对于任何文件/目录的索引都必须从根目录开始向下逐级进行。等到索引完成之后， <code class="docutils literal notranslate"><span class="pre">EasyFileSystem</span></code> 才能对文件/目录进行操作。事实上 <code class="docutils literal notranslate"><span class="pre">EasyFileSystem</span></code> 提供了另一个名为 <code class="docutils literal notranslate"><span class="pre">root_inode</span></code> 的方法来获取根目录的 <code class="docutils literal notranslate"><span class="pre">Inode</span></code> :</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// easy-fs/src/efs.rs</span>

<span class="k">impl</span><span class="w"> </span><span class="n">EasyFileSystem</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">root_inode</span><span class="p">(</span><span class="n">efs</span>: <span class="kp">&amp;</span><span class="nc">Arc</span><span class="o">&lt;</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="bp">Self</span><span class="o">&gt;&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Inode</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">block_device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Arc</span>::<span class="n">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efs</span><span class="p">.</span><span class="n">lock</span><span class="p">().</span><span class="n">block_device</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// acquire efs lock temporarily</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">block_id</span><span class="p">,</span><span class="w"> </span><span class="n">block_offset</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">efs</span><span class="p">.</span><span class="n">lock</span><span class="p">().</span><span class="n">get_disk_inode_pos</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// release efs lock</span>
<span class="w">        </span><span class="n">Inode</span>::<span class="n">new</span><span class="p">(</span>
<span class="w">            </span><span class="n">block_id</span><span class="p">,</span>
<span class="w">            </span><span class="n">block_offset</span><span class="p">,</span>
<span class="w">            </span><span class="n">Arc</span>::<span class="n">clone</span><span class="p">(</span><span class="n">efs</span><span class="p">),</span>
<span class="w">            </span><span class="n">block_device</span><span class="p">,</span>
<span class="w">        </span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// easy-fs/src/vfs.rs</span>

<span class="k">impl</span><span class="w"> </span><span class="n">Inode</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="sd">/// We should not acquire efs lock here.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span>
<span class="w">        </span><span class="n">block_id</span>: <span class="kt">u32</span><span class="p">,</span>
<span class="w">        </span><span class="n">block_offset</span>: <span class="kt">usize</span><span class="p">,</span>
<span class="w">        </span><span class="n">fs</span>: <span class="nc">Arc</span><span class="o">&lt;</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="n">EasyFileSystem</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="w">        </span><span class="n">block_device</span>: <span class="nc">Arc</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">BlockDevice</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">    </span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">block_id</span>: <span class="nc">block_id</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span>
<span class="w">            </span><span class="n">block_offset</span><span class="p">,</span>
<span class="w">            </span><span class="n">fs</span><span class="p">,</span>
<span class="w">            </span><span class="n">block_device</span><span class="p">,</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>对于 <code class="docutils literal notranslate"><span class="pre">root_inode</span></code> 的初始化，是在调用 <code class="docutils literal notranslate"><span class="pre">Inode::new</span></code> 时将传入的 <code class="docutils literal notranslate"><span class="pre">inode_id</span></code> 设置为 0 ，因为根目录对应于文件系统中第一个分配的 inode ，因此它的 <code class="docutils literal notranslate"><span class="pre">inode_id</span></code> 总会是 0 。不会在调用 <code class="docutils literal notranslate"><span class="pre">Inode::new</span></code> 过程中尝试获取整个 <code class="docutils literal notranslate"><span class="pre">EasyFileSystem</span></code> 的锁来查询 inode 在块设备中的位置，而是在调用它之前预先查询并作为参数传过去。</p>
</div>
<div class="section" id="id15">
<h3>文件索引<a class="headerlink" href="#id15" title="永久链接至标题">#</a></h3>
<p><a class="reference internal" href="1fs-interface.html#fs-simplification"><span class="std std-ref">前面</span></a> 提到过，为了尽可能简化文件系统设计， <code class="docutils literal notranslate"><span class="pre">EasyFileSystem</span></code> 是一个扁平化的文件系统，即在目录树上仅有一个目录——那就是作为根节点的根目录。所有的文件都在根目录下面。于是，我们不必实现目录索引。文件索引的查找比较简单，仅需在根目录的目录项中根据文件名找到文件的 inode 编号即可。由于没有子目录的存在，这个过程只会进行一次。</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// easy-fs/src/vfs.rs</span>

<span class="k">impl</span><span class="w"> </span><span class="n">Inode</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">find</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">name</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Arc</span><span class="o">&lt;</span><span class="n">Inode</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">fs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">fs</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">read_disk_inode</span><span class="p">(</span><span class="o">|</span><span class="n">disk_inode</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">find_inode_id</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">disk_inode</span><span class="p">)</span>
<span class="w">            </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">inode_id</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">block_id</span><span class="p">,</span><span class="w"> </span><span class="n">block_offset</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fs</span><span class="p">.</span><span class="n">get_disk_inode_pos</span><span class="p">(</span><span class="n">inode_id</span><span class="p">);</span>
<span class="w">                </span><span class="n">Arc</span>::<span class="n">new</span><span class="p">(</span><span class="bp">Self</span>::<span class="n">new</span><span class="p">(</span>
<span class="w">                    </span><span class="n">block_id</span><span class="p">,</span>
<span class="w">                    </span><span class="n">block_offset</span><span class="p">,</span>
<span class="w">                    </span><span class="bp">self</span><span class="p">.</span><span class="n">fs</span><span class="p">.</span><span class="n">clone</span><span class="p">(),</span>
<span class="w">                    </span><span class="bp">self</span><span class="p">.</span><span class="n">block_device</span><span class="p">.</span><span class="n">clone</span><span class="p">(),</span>
<span class="w">                </span><span class="p">))</span>
<span class="w">            </span><span class="p">})</span>
<span class="w">        </span><span class="p">})</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">find_inode_id</span><span class="p">(</span>
<span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span>
<span class="w">        </span><span class="n">name</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">,</span>
<span class="w">        </span><span class="n">disk_inode</span>: <span class="kp">&amp;</span><span class="nc">DiskInode</span><span class="p">,</span>
<span class="w">    </span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// assert it is a directory</span>
<span class="w">        </span><span class="fm">assert!</span><span class="p">(</span><span class="n">disk_inode</span><span class="p">.</span><span class="n">is_dir</span><span class="p">());</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">file_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">disk_inode</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">DIRENT_SZ</span><span class="p">;</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">dirent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DirEntry</span>::<span class="n">empty</span><span class="p">();</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="n">file_count</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span>
<span class="w">                </span><span class="n">disk_inode</span><span class="p">.</span><span class="n">read_at</span><span class="p">(</span>
<span class="w">                    </span><span class="n">DIRENT_SZ</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i</span><span class="p">,</span>
<span class="w">                    </span><span class="n">dirent</span><span class="p">.</span><span class="n">as_bytes_mut</span><span class="p">(),</span>
<span class="w">                    </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">block_device</span><span class="p">,</span>
<span class="w">                </span><span class="p">),</span>
<span class="w">                </span><span class="n">DIRENT_SZ</span><span class="p">,</span>
<span class="w">            </span><span class="p">);</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">dirent</span><span class="p">.</span><span class="n">name</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">dirent</span><span class="p">.</span><span class="n">inode_number</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="nb">None</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">find</span></code> 方法只会被根目录 <code class="docutils literal notranslate"><span class="pre">Inode</span></code> 调用，文件系统中其他文件的 <code class="docutils literal notranslate"><span class="pre">Inode</span></code> 不会调用这个方法。它首先调用 <code class="docutils literal notranslate"><span class="pre">find_inode_id</span></code> 方法，尝试从根目录的 <code class="docutils literal notranslate"><span class="pre">DiskInode</span></code> 上找到要索引的文件名对应的 inode 编号。这就需要将根目录内容中的所有目录项都读到内存进行逐个比对。如果能够找到，则 <code class="docutils literal notranslate"><span class="pre">find</span></code> 方法会根据查到 inode 编号，对应生成一个 <code class="docutils literal notranslate"><span class="pre">Inode</span></code> 用于后续对文件的访问。</p>
<p>这里需要注意，包括 <code class="docutils literal notranslate"><span class="pre">find</span></code> 在内，所有暴露给文件系统的使用者的文件系统操作（还包括接下来将要介绍的几种），全程均需持有 <code class="docutils literal notranslate"><span class="pre">EasyFileSystem</span></code> 的互斥锁（相对而言，文件系统内部的操作，如之前的 <code class="docutils literal notranslate"><span class="pre">Inode::new</span></code> 或是上面的 <code class="docutils literal notranslate"><span class="pre">find_inode_id</span></code> ，都是假定在已持有 efs 锁的情况下才被调用的，因此它们不应尝试获取锁）。这能够保证在多核情况下，同时最多只能有一个核在进行文件系统相关操作。这样也许会带来一些不必要的性能损失，但我们目前暂时先这样做。如果我们在这里加锁的话，其实就能够保证块缓存的互斥访问了。</p>
</div>
<div class="section" id="id16">
<h3>文件列举<a class="headerlink" href="#id16" title="永久链接至标题">#</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">ls</span></code> 方法可以收集根目录下的所有文件的文件名并以向量的形式返回，这个方法只有根目录的 <code class="docutils literal notranslate"><span class="pre">Inode</span></code> 才会调用：</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// easy-fs/src/vfs.rs</span>

<span class="k">impl</span><span class="w"> </span><span class="n">Inode</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">ls</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">_fs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">fs</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">read_disk_inode</span><span class="p">(</span><span class="o">|</span><span class="n">disk_inode</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">file_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">disk_inode</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">DIRENT_SZ</span><span class="p">;</span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">v</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">new</span><span class="p">();</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="n">file_count</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">dirent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DirEntry</span>::<span class="n">empty</span><span class="p">();</span>
<span class="w">                </span><span class="fm">assert_eq!</span><span class="p">(</span>
<span class="w">                    </span><span class="n">disk_inode</span><span class="p">.</span><span class="n">read_at</span><span class="p">(</span>
<span class="w">                        </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">DIRENT_SZ</span><span class="p">,</span>
<span class="w">                        </span><span class="n">dirent</span><span class="p">.</span><span class="n">as_bytes_mut</span><span class="p">(),</span>
<span class="w">                        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">block_device</span><span class="p">,</span>
<span class="w">                    </span><span class="p">),</span>
<span class="w">                    </span><span class="n">DIRENT_SZ</span><span class="p">,</span>
<span class="w">                </span><span class="p">);</span>
<span class="w">                </span><span class="n">v</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="n">dirent</span><span class="p">.</span><span class="n">name</span><span class="p">()));</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="n">v</span>
<span class="w">        </span><span class="p">})</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p><strong>Rust 语法卡片： _ 在匹配中的使用方法</strong></p>
<p>可以看到在 <code class="docutils literal notranslate"><span class="pre">ls</span></code> 操作中，我们虽然获取了 efs 锁，但是这里并不会直接访问 <code class="docutils literal notranslate"><span class="pre">EasyFileSystem</span></code> 实例，其目的仅仅是锁住该实例避免其他核在同时间的访问造成并发冲突。因此，我们将其绑定到以 <code class="docutils literal notranslate"><span class="pre">_</span></code> 开头的变量 <code class="docutils literal notranslate"><span class="pre">_fs</span></code> 中，这样即使我们在其作用域中并没有使用它，编译器也不会报警告。然而，我们不能将其绑定到变量 <code class="docutils literal notranslate"><span class="pre">_</span></code> 上。因为从匹配规则可以知道这意味着该操作会被编译器丢弃，从而无法达到获取锁的效果。</p>
</div>
</div>
<div class="section" id="id17">
<h3>文件创建<a class="headerlink" href="#id17" title="永久链接至标题">#</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">create</span></code> 方法可以在根目录下创建一个文件，该方法只有根目录的 <code class="docutils literal notranslate"><span class="pre">Inode</span></code> 会调用：</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="c1">// easy-fs/src/vfs.rs</span>
<span class="linenos"> 2</span>
<span class="linenos"> 3</span><span class="k">impl</span><span class="w"> </span><span class="n">Inode</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 4</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">create</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">name</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Arc</span><span class="o">&lt;</span><span class="n">Inode</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 5</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">fs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">fs</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
<span class="linenos"> 6</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">modify_disk_inode</span><span class="p">(</span><span class="o">|</span><span class="n">root_inode</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 7</span><span class="w">            </span><span class="c1">// assert it is a directory</span>
<span class="linenos"> 8</span><span class="w">            </span><span class="fm">assert!</span><span class="p">(</span><span class="n">root_inode</span><span class="p">.</span><span class="n">is_dir</span><span class="p">());</span>
<span class="linenos"> 9</span><span class="w">            </span><span class="c1">// has the file been created?</span>
<span class="linenos">10</span><span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">find_inode_id</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">root_inode</span><span class="p">)</span>
<span class="linenos">11</span><span class="w">        </span><span class="p">}).</span><span class="n">is_some</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">12</span><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">None</span><span class="p">;</span>
<span class="linenos">13</span><span class="w">        </span><span class="p">}</span>
<span class="linenos">14</span><span class="w">        </span><span class="c1">// create a new file</span>
<span class="linenos">15</span><span class="w">        </span><span class="c1">// alloc a inode with an indirect block</span>
<span class="linenos">16</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">new_inode_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fs</span><span class="p">.</span><span class="n">alloc_inode</span><span class="p">();</span>
<span class="linenos">17</span><span class="w">        </span><span class="c1">// initialize inode</span>
<span class="linenos">18</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">new_inode_block_id</span><span class="p">,</span><span class="w"> </span><span class="n">new_inode_block_offset</span><span class="p">)</span>
<span class="linenos">19</span><span class="w">            </span><span class="o">=</span><span class="w"> </span><span class="n">fs</span><span class="p">.</span><span class="n">get_disk_inode_pos</span><span class="p">(</span><span class="n">new_inode_id</span><span class="p">);</span>
<span class="linenos">20</span><span class="w">        </span><span class="n">get_block_cache</span><span class="p">(</span>
<span class="linenos">21</span><span class="w">            </span><span class="n">new_inode_block_id</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span>
<span class="linenos">22</span><span class="w">            </span><span class="n">Arc</span>::<span class="n">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">block_device</span><span class="p">)</span>
<span class="linenos">23</span><span class="w">        </span><span class="p">).</span><span class="n">lock</span><span class="p">().</span><span class="n">modify</span><span class="p">(</span><span class="n">new_inode_block_offset</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">new_inode</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">DiskInode</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">24</span><span class="w">            </span><span class="n">new_inode</span><span class="p">.</span><span class="n">initialize</span><span class="p">(</span><span class="n">DiskInodeType</span>::<span class="n">File</span><span class="p">);</span>
<span class="linenos">25</span><span class="w">        </span><span class="p">});</span>
<span class="linenos">26</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">modify_disk_inode</span><span class="p">(</span><span class="o">|</span><span class="n">root_inode</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">27</span><span class="w">            </span><span class="c1">// append file in the dirent</span>
<span class="linenos">28</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">file_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">root_inode</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">DIRENT_SZ</span><span class="p">;</span>
<span class="linenos">29</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">new_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">file_count</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">DIRENT_SZ</span><span class="p">;</span>
<span class="linenos">30</span><span class="w">            </span><span class="c1">// increase size</span>
<span class="linenos">31</span><span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">increase_size</span><span class="p">(</span><span class="n">new_size</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">root_inode</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">fs</span><span class="p">);</span>
<span class="linenos">32</span><span class="w">            </span><span class="c1">// write dirent</span>
<span class="linenos">33</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">dirent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DirEntry</span>::<span class="n">new</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">new_inode_id</span><span class="p">);</span>
<span class="linenos">34</span><span class="w">            </span><span class="n">root_inode</span><span class="p">.</span><span class="n">write_at</span><span class="p">(</span>
<span class="linenos">35</span><span class="w">                </span><span class="n">file_count</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">DIRENT_SZ</span><span class="p">,</span>
<span class="linenos">36</span><span class="w">                </span><span class="n">dirent</span><span class="p">.</span><span class="n">as_bytes</span><span class="p">(),</span>
<span class="linenos">37</span><span class="w">                </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">block_device</span><span class="p">,</span>
<span class="linenos">38</span><span class="w">            </span><span class="p">);</span>
<span class="linenos">39</span><span class="w">        </span><span class="p">});</span>
<span class="linenos">40</span>
<span class="linenos">41</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">block_id</span><span class="p">,</span><span class="w"> </span><span class="n">block_offset</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fs</span><span class="p">.</span><span class="n">get_disk_inode_pos</span><span class="p">(</span><span class="n">new_inode_id</span><span class="p">);</span>
<span class="linenos">42</span><span class="w">        </span><span class="c1">// return inode</span>
<span class="linenos">43</span><span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="n">Arc</span>::<span class="n">new</span><span class="p">(</span><span class="bp">Self</span>::<span class="n">new</span><span class="p">(</span>
<span class="linenos">44</span><span class="w">            </span><span class="n">block_id</span><span class="p">,</span>
<span class="linenos">45</span><span class="w">            </span><span class="n">block_offset</span><span class="p">,</span>
<span class="linenos">46</span><span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">fs</span><span class="p">.</span><span class="n">clone</span><span class="p">(),</span>
<span class="linenos">47</span><span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">block_device</span><span class="p">.</span><span class="n">clone</span><span class="p">(),</span>
<span class="linenos">48</span><span class="w">        </span><span class="p">)))</span>
<span class="linenos">49</span><span class="w">        </span><span class="c1">// release efs lock automatically by compiler</span>
<span class="linenos">50</span><span class="w">    </span><span class="p">}</span>
<span class="linenos">51</span><span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>第 6~13 行，检查文件是否已经在根目录下，如果找到的话返回 <code class="docutils literal notranslate"><span class="pre">None</span></code> ；</p></li>
<li><p>第 14~25 行，为待创建文件分配一个新的 inode 并进行初始化；</p></li>
<li><p>第 26~39 行，将待创建文件的目录项插入到根目录的内容中，使得之后可以索引到。</p></li>
</ul>
</div>
<div class="section" id="id18">
<h3>文件清空<a class="headerlink" href="#id18" title="永久链接至标题">#</a></h3>
<p>在以某些标志位打开文件（例如带有 <em>CREATE</em> 标志打开一个已经存在的文件）的时候，需要首先将文件清空。在索引到文件的 <code class="docutils literal notranslate"><span class="pre">Inode</span></code> 之后，可以调用 <code class="docutils literal notranslate"><span class="pre">clear</span></code> 方法：</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// easy-fs/src/vfs.rs</span>

<span class="k">impl</span><span class="w"> </span><span class="n">Inode</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">clear</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">fs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">fs</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">modify_disk_inode</span><span class="p">(</span><span class="o">|</span><span class="n">disk_inode</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">disk_inode</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">data_blocks_dealloc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">disk_inode</span><span class="p">.</span><span class="n">clear_size</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">block_device</span><span class="p">);</span>
<span class="w">            </span><span class="fm">assert!</span><span class="p">(</span><span class="n">data_blocks_dealloc</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">DiskInode</span>::<span class="n">total_blocks</span><span class="p">(</span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">);</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="n">data_block</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">data_blocks_dealloc</span><span class="p">.</span><span class="n">into_iter</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">fs</span><span class="p">.</span><span class="n">dealloc_data</span><span class="p">(</span><span class="n">data_block</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">});</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这会将该文件占据的索引块和数据块回收。</p>
</div>
<div class="section" id="id19">
<h3>文件读写<a class="headerlink" href="#id19" title="永久链接至标题">#</a></h3>
<p>从根目录索引到一个文件之后，可以对它进行读写。注意：和 <code class="docutils literal notranslate"><span class="pre">DiskInode</span></code> 一样，这里的读写作用在字节序列的一段区间上：</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// easy-fs/src/vfs.rs</span>

<span class="k">impl</span><span class="w"> </span><span class="n">Inode</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">read_at</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="kt">usize</span> <span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">_fs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">fs</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">read_disk_inode</span><span class="p">(</span><span class="o">|</span><span class="n">disk_inode</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">disk_inode</span><span class="p">.</span><span class="n">read_at</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">block_device</span><span class="p">)</span>
<span class="w">        </span><span class="p">})</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">write_at</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="kt">usize</span> <span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">fs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">fs</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">modify_disk_inode</span><span class="p">(</span><span class="o">|</span><span class="n">disk_inode</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">increase_size</span><span class="p">((</span><span class="n">offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">buf</span><span class="p">.</span><span class="n">len</span><span class="p">())</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">disk_inode</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">fs</span><span class="p">);</span>
<span class="w">            </span><span class="n">disk_inode</span><span class="p">.</span><span class="n">write_at</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">block_device</span><span class="p">)</span>
<span class="w">        </span><span class="p">})</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>具体实现比较简单，需要注意在执行 <code class="docutils literal notranslate"><span class="pre">DiskInode::write_at</span></code> 之前先调用 <code class="docutils literal notranslate"><span class="pre">increase_size</span></code> 对自身进行扩容：</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// easy-fs/src/vfs.rs</span>

<span class="k">impl</span><span class="w"> </span><span class="n">Inode</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">increase_size</span><span class="p">(</span>
<span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span>
<span class="w">        </span><span class="n">new_size</span>: <span class="kt">u32</span><span class="p">,</span>
<span class="w">        </span><span class="n">disk_inode</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">DiskInode</span><span class="p">,</span>
<span class="w">        </span><span class="n">fs</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">MutexGuard</span><span class="o">&lt;</span><span class="n">EasyFileSystem</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">    </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">new_size</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">disk_inode</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">blocks_needed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">disk_inode</span><span class="p">.</span><span class="n">blocks_num_needed</span><span class="p">(</span><span class="n">new_size</span><span class="p">);</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">v</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">new</span><span class="p">();</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="n">blocks_needed</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">v</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">fs</span><span class="p">.</span><span class="n">alloc_data</span><span class="p">());</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">disk_inode</span><span class="p">.</span><span class="n">increase_size</span><span class="p">(</span><span class="n">new_size</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">block_device</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这里会从 <code class="docutils literal notranslate"><span class="pre">EasyFileSystem</span></code> 中分配一些用于扩容的数据块并传给 <code class="docutils literal notranslate"><span class="pre">DiskInode::increase_size</span></code> 。</p>
</div>
</div>
<div class="section" id="id20">
<h2>在用户态测试 easy-fs 的功能<a class="headerlink" href="#id20" title="永久链接至标题">#</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">easy-fs</span></code> 架构设计的一个优点在于它可以在Rust应用开发环境（Windows/macOS/Ubuntu）中，按照应用程序库的开发方式来进行测试，不必过早的放到内核中测试运行。众所周知，内核运行在裸机环境上，对其进行调试很困难。而面向应用的开发环境对于调试的支持更为完善，从基于命令行的 GDB 到 IDE 提供的图形化调试界面都能给文件系统的开发带来很大帮助。另外一点是，由于 <code class="docutils literal notranslate"><span class="pre">easy-fs</span></code> 需要放到在裸机上运行的内核中，使得 <code class="docutils literal notranslate"><span class="pre">easy-fs</span></code> 只能使用 <code class="docutils literal notranslate"><span class="pre">no_std</span></code> 模式，不能在 <code class="docutils literal notranslate"><span class="pre">easy-fs</span></code> 中调用标准库 <code class="docutils literal notranslate"><span class="pre">std</span></code> 。但是在把 <code class="docutils literal notranslate"><span class="pre">easy-fs</span></code> 作为一个应用的库运行的时候，可以暂时让使用它的应用程序调用标准库 <code class="docutils literal notranslate"><span class="pre">std</span></code> ，这也会在开发调试上带来一些方便。</p>
<p><code class="docutils literal notranslate"><span class="pre">easy-fs</span></code> 的测试放在另一个名为 <code class="docutils literal notranslate"><span class="pre">easy-fs-fuse</span></code> 的应用程序中，不同于 <code class="docutils literal notranslate"><span class="pre">easy-fs</span></code> ，它是一个可以调用标准库  <code class="docutils literal notranslate"><span class="pre">std</span></code> 的应用程序 ，能够在Rust应用开发环境上运行并很容易调试。</p>
<div class="section" id="rust">
<h3>在Rust应用开发环境中模拟块设备<a class="headerlink" href="#rust" title="永久链接至标题">#</a></h3>
<p>从文件系统的使用者角度来看，它仅需要提供一个实现了 <code class="docutils literal notranslate"><span class="pre">BlockDevice</span></code> Trait 的块设备用来装载文件系统，之后就可以使用 <code class="docutils literal notranslate"><span class="pre">Inode</span></code> 来方便地进行文件系统操作了。但是在开发环境上，我们如何来提供这样一个块设备呢？答案是用 Linux （当然也可以是Windows/MacOS等其它通用操作系统）上的一个文件模拟一个块设备。</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// easy-fs-fuse/src/main.rs</span>

<span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span>
<span class="k">use</span><span class="w"> </span><span class="n">easy</span><span class="o">-</span><span class="n">fs</span>::<span class="n">BlockDevice</span><span class="p">;</span>

<span class="k">const</span><span class="w"> </span><span class="n">BLOCK_SZ</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="mi">512</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">BlockFile</span><span class="p">(</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="n">File</span><span class="o">&gt;</span><span class="p">);</span>

<span class="k">impl</span><span class="w"> </span><span class="n">BlockDevice</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">BlockFile</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">read_block</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">block_id</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="mf">0.</span><span class="n">lock</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">        </span><span class="n">file</span><span class="p">.</span><span class="n">seek</span><span class="p">(</span><span class="n">SeekFrom</span>::<span class="n">Start</span><span class="p">((</span><span class="n">block_id</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">BLOCK_SZ</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u64</span><span class="p">))</span>
<span class="w">            </span><span class="p">.</span><span class="n">expect</span><span class="p">(</span><span class="s">&quot;Error when seeking!&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">file</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">buf</span><span class="p">).</span><span class="n">unwrap</span><span class="p">(),</span><span class="w"> </span><span class="n">BLOCK_SZ</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Not a complete block!&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">write_block</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">block_id</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="mf">0.</span><span class="n">lock</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">        </span><span class="n">file</span><span class="p">.</span><span class="n">seek</span><span class="p">(</span><span class="n">SeekFrom</span>::<span class="n">Start</span><span class="p">((</span><span class="n">block_id</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">BLOCK_SZ</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u64</span><span class="p">))</span>
<span class="w">            </span><span class="p">.</span><span class="n">expect</span><span class="p">(</span><span class="s">&quot;Error when seeking!&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">file</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">buf</span><span class="p">).</span><span class="n">unwrap</span><span class="p">(),</span><span class="w"> </span><span class="n">BLOCK_SZ</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Not a complete block!&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">std::file::File</span></code> 由 Rust 标准库 std 提供，可以访问 Linux 上的一个文件。我们将它包装成 <code class="docutils literal notranslate"><span class="pre">BlockFile</span></code> 类型来模拟一块磁盘，为它实现 <code class="docutils literal notranslate"><span class="pre">BlockDevice</span></code> 接口。注意 <code class="docutils literal notranslate"><span class="pre">File</span></code> 本身仅通过 <code class="docutils literal notranslate"><span class="pre">read/write</span></code> 接口是不能实现随机读写的，在访问一个特定的块的时候，我们必须先 <code class="docutils literal notranslate"><span class="pre">seek</span></code> 到这个块的开头位置。</p>
<p>测试主函数为 <code class="docutils literal notranslate"><span class="pre">easy-fs-fuse/src/main.rs</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">efs_test</span></code> 函数中，我们只需在 <code class="docutils literal notranslate"><span class="pre">easy-fs-fuse</span></code> 目录下 <code class="docutils literal notranslate"><span class="pre">cargo</span> <span class="pre">test</span></code> 即可执行该测试：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">running</span> <span class="mi">1</span> <span class="n">test</span>
<span class="n">test</span> <span class="n">efs_test</span> <span class="o">...</span> <span class="n">ok</span>

<span class="n">test</span> <span class="n">result</span><span class="p">:</span> <span class="n">ok</span><span class="o">.</span> <span class="mi">1</span> <span class="n">passed</span><span class="p">;</span> <span class="mi">0</span> <span class="n">failed</span><span class="p">;</span> <span class="mi">0</span> <span class="n">ignored</span><span class="p">;</span> <span class="mi">0</span> <span class="n">measured</span><span class="p">;</span> <span class="mi">0</span> <span class="n">filtered</span> <span class="n">out</span><span class="p">;</span> <span class="n">finished</span> <span class="ow">in</span> <span class="mf">1.27</span><span class="n">s</span>
</pre></div>
</div>
<p>看到上面的内容就说明测试通过了。</p>
<p><code class="docutils literal notranslate"><span class="pre">efs_test</span></code> 展示了 <code class="docutils literal notranslate"><span class="pre">easy-fs</span></code> 库的使用方法，大致分成以下几个步骤：</p>
</div>
<div class="section" id="id21">
<h3>打开块设备<a class="headerlink" href="#id21" title="永久链接至标题">#</a></h3>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="n">block_file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Arc</span>::<span class="n">new</span><span class="p">(</span><span class="n">BlockFile</span><span class="p">(</span><span class="n">Mutex</span>::<span class="n">new</span><span class="p">({</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">OpenOptions</span>::<span class="n">new</span><span class="p">()</span>
<span class="w">        </span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
<span class="w">        </span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
<span class="w">        </span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
<span class="w">        </span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="s">&quot;target/fs.img&quot;</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
<span class="w">    </span><span class="n">f</span><span class="p">.</span><span class="n">set_len</span><span class="p">(</span><span class="mi">8192</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">512</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">    </span><span class="n">f</span>
<span class="p">})));</span>
<span class="n">EasyFileSystem</span>::<span class="n">create</span><span class="p">(</span>
<span class="w">    </span><span class="n">block_file</span><span class="p">.</span><span class="n">clone</span><span class="p">(),</span>
<span class="w">    </span><span class="mi">4096</span><span class="p">,</span>
<span class="w">    </span><span class="mi">1</span><span class="p">,</span>
<span class="p">);</span>
</pre></div>
</div>
<p>第一步我们需要打开虚拟块设备。这里我们在 Linux 上创建文件 <code class="docutils literal notranslate"><span class="pre">easy-fs-fuse/target/fs.img</span></code> 来新建一个虚拟块设备，并将它的容量设置为 8192 个块即 4MiB 。在创建的时候需要将它的访问权限设置为可读可写。</p>
<p>由于我们在进行测试，需要初始化测试环境，因此在虚拟块设备 <code class="docutils literal notranslate"><span class="pre">block_file</span></code> 上初始化 easy-fs 文件系统，这会将 <code class="docutils literal notranslate"><span class="pre">block_file</span></code> 用于放置 easy-fs 镜像的前 4096 个块上的数据覆盖，然后变成仅有一个根目录的初始文件系统。如果块设备上已经放置了一个合法的 easy-fs 镜像，则我们不必这样做。</p>
</div>
<div class="section" id="id22">
<h3>从块设备上打开文件系统<a class="headerlink" href="#id22" title="永久链接至标题">#</a></h3>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="n">efs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EasyFileSystem</span>::<span class="n">open</span><span class="p">(</span><span class="n">block_file</span><span class="p">.</span><span class="n">clone</span><span class="p">());</span>
</pre></div>
</div>
<p>这是通常进行的第二个步骤。</p>
</div>
<div class="section" id="id23">
<h3>获取根目录的 Inode<a class="headerlink" href="#id23" title="永久链接至标题">#</a></h3>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="n">root_inode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EasyFileSystem</span>::<span class="n">root_inode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efs</span><span class="p">);</span>
</pre></div>
</div>
<p>这是通常进行的第三个步骤。</p>
</div>
<div class="section" id="id24">
<h3>进行各种文件操作<a class="headerlink" href="#id24" title="永久链接至标题">#</a></h3>
<p>拿到根目录 <code class="docutils literal notranslate"><span class="pre">root_inode</span></code> 之后，可以通过它进行各种文件操作，目前支持以下几种：</p>
<ul class="simple">
<li><p>通过 <code class="docutils literal notranslate"><span class="pre">create</span></code> 创建文件。</p></li>
<li><p>通过 <code class="docutils literal notranslate"><span class="pre">ls</span></code> 列举根目录下的文件。</p></li>
<li><p>通过 <code class="docutils literal notranslate"><span class="pre">find</span></code> 根据文件名索引文件。</p></li>
</ul>
<p>当通过索引获取根目录下的一个文件的 inode 之后则可以进行如下操作：</p>
<ul class="simple">
<li><p>通过 <code class="docutils literal notranslate"><span class="pre">clear</span></code> 将文件内容清空。</p></li>
<li><p>通过 <code class="docutils literal notranslate"><span class="pre">read/write_at</span></code> 读写文件，注意我们需要将读写在文件中开始的位置 <code class="docutils literal notranslate"><span class="pre">offset</span></code> 作为一个参数传递进去。</p></li>
</ul>
<p>测试方法在这里不详细介绍，大概是每次清空文件 <code class="docutils literal notranslate"><span class="pre">filea</span></code> 的内容，向其中写入一个不同长度的随机数字字符串，然后再全部读取出来，验证和写入的内容一致。其中有一个细节是：用来生成随机字符串的 <code class="docutils literal notranslate"><span class="pre">rand</span></code> crate 并不支持 <code class="docutils literal notranslate"><span class="pre">no_std</span></code> ，因此只有在用户态我们才能更容易进行测试。</p>
</div>
</div>
<div class="section" id="id25">
<h2>将应用打包为 easy-fs 镜像<a class="headerlink" href="#id25" title="永久链接至标题">#</a></h2>
<p>在第六章中我们需要将所有的应用都链接到内核中，随后在应用管理器中通过应用名进行索引来找到应用的 ELF 数据。这样做有一个缺点，就是会造成内核体积过度膨胀。在 k210 平台上可以很明显的感觉到从第五章开始随着应用数量的增加，向开发板上烧写内核镜像的耗时显著增长。同时这也会浪费内存资源，因为未被执行的应用也占据了内存空间。在实现了 easy-fs 文件系统之后，终于可以将这些应用打包到 easy-fs 镜像中放到磁盘中，当我们要执行应用的时候只需从文件系统中取出ELF 执行文件格式的应用 并加载到内存中执行即可，这样就避免了前面章节的存储开销等问题。</p>
<p><code class="docutils literal notranslate"><span class="pre">easy-fs-fuse</span></code> 的主体 <code class="docutils literal notranslate"><span class="pre">easy-fs-pack</span></code> 函数就实现了这个功能：</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="c1">// easy-fs-fuse/src/main.rs</span>
<span class="linenos"> 2</span>
<span class="linenos"> 3</span><span class="k">use</span><span class="w"> </span><span class="n">clap</span>::<span class="p">{</span><span class="n">Arg</span><span class="p">,</span><span class="w"> </span><span class="n">App</span><span class="p">};</span>
<span class="linenos"> 4</span>
<span class="linenos"> 5</span><span class="k">fn</span> <span class="nf">easy_fs_pack</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">std</span>::<span class="n">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 6</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">matches</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">App</span>::<span class="n">new</span><span class="p">(</span><span class="s">&quot;EasyFileSystem packer&quot;</span><span class="p">)</span>
<span class="linenos"> 7</span><span class="w">        </span><span class="p">.</span><span class="n">arg</span><span class="p">(</span><span class="n">Arg</span>::<span class="n">with_name</span><span class="p">(</span><span class="s">&quot;source&quot;</span><span class="p">)</span>
<span class="linenos"> 8</span><span class="w">            </span><span class="p">.</span><span class="n">short</span><span class="p">(</span><span class="s">&quot;s&quot;</span><span class="p">)</span>
<span class="linenos"> 9</span><span class="w">            </span><span class="p">.</span><span class="n">long</span><span class="p">(</span><span class="s">&quot;source&quot;</span><span class="p">)</span>
<span class="linenos">10</span><span class="w">            </span><span class="p">.</span><span class="n">takes_value</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
<span class="linenos">11</span><span class="w">            </span><span class="p">.</span><span class="n">help</span><span class="p">(</span><span class="s">&quot;Executable source dir(with backslash)&quot;</span><span class="p">)</span>
<span class="linenos">12</span><span class="w">        </span><span class="p">)</span>
<span class="linenos">13</span><span class="w">        </span><span class="p">.</span><span class="n">arg</span><span class="p">(</span><span class="n">Arg</span>::<span class="n">with_name</span><span class="p">(</span><span class="s">&quot;target&quot;</span><span class="p">)</span>
<span class="linenos">14</span><span class="w">            </span><span class="p">.</span><span class="n">short</span><span class="p">(</span><span class="s">&quot;t&quot;</span><span class="p">)</span>
<span class="linenos">15</span><span class="w">            </span><span class="p">.</span><span class="n">long</span><span class="p">(</span><span class="s">&quot;target&quot;</span><span class="p">)</span>
<span class="linenos">16</span><span class="w">            </span><span class="p">.</span><span class="n">takes_value</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
<span class="linenos">17</span><span class="w">            </span><span class="p">.</span><span class="n">help</span><span class="p">(</span><span class="s">&quot;Executable target dir(with backslash)&quot;</span><span class="p">)</span>
<span class="linenos">18</span><span class="w">        </span><span class="p">)</span>
<span class="linenos">19</span><span class="w">        </span><span class="p">.</span><span class="n">get_matches</span><span class="p">();</span>
<span class="linenos">20</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">src_path</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">matches</span><span class="p">.</span><span class="n">value_of</span><span class="p">(</span><span class="s">&quot;source&quot;</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>
<span class="linenos">21</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">target_path</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">matches</span><span class="p">.</span><span class="n">value_of</span><span class="p">(</span><span class="s">&quot;target&quot;</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>
<span class="linenos">22</span><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;src_path = {}</span><span class="se">\n</span><span class="s">target_path = {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">src_path</span><span class="p">,</span><span class="w"> </span><span class="n">target_path</span><span class="p">);</span>
<span class="linenos">23</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">block_file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Arc</span>::<span class="n">new</span><span class="p">(</span><span class="n">BlockFile</span><span class="p">(</span><span class="n">Mutex</span>::<span class="n">new</span><span class="p">({</span>
<span class="linenos">24</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">OpenOptions</span>::<span class="n">new</span><span class="p">()</span>
<span class="linenos">25</span><span class="w">            </span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
<span class="linenos">26</span><span class="w">            </span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
<span class="linenos">27</span><span class="w">            </span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
<span class="linenos">28</span><span class="w">            </span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="fm">format!</span><span class="p">(</span><span class="s">&quot;{}{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">target_path</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;fs.img&quot;</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>
<span class="linenos">29</span><span class="w">        </span><span class="n">f</span><span class="p">.</span><span class="n">set_len</span><span class="p">(</span><span class="mi">8192</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">512</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>
<span class="linenos">30</span><span class="w">        </span><span class="n">f</span>
<span class="linenos">31</span><span class="w">    </span><span class="p">})));</span>
<span class="linenos">32</span><span class="w">    </span><span class="c1">// 4MiB, at most 4095 files</span>
<span class="linenos">33</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">efs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EasyFileSystem</span>::<span class="n">create</span><span class="p">(</span>
<span class="linenos">34</span><span class="w">        </span><span class="n">block_file</span><span class="p">.</span><span class="n">clone</span><span class="p">(),</span>
<span class="linenos">35</span><span class="w">        </span><span class="mi">8192</span><span class="p">,</span>
<span class="linenos">36</span><span class="w">        </span><span class="mi">1</span><span class="p">,</span>
<span class="linenos">37</span><span class="w">    </span><span class="p">);</span>
<span class="linenos">38</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">root_inode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Arc</span>::<span class="n">new</span><span class="p">(</span><span class="n">EasyFileSystem</span>::<span class="n">root_inode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">efs</span><span class="p">));</span>
<span class="linenos">39</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">apps</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">read_dir</span><span class="p">(</span><span class="n">src_path</span><span class="p">)</span>
<span class="linenos">40</span><span class="w">        </span><span class="p">.</span><span class="n">unwrap</span><span class="p">()</span>
<span class="linenos">41</span><span class="w">        </span><span class="p">.</span><span class="n">into_iter</span><span class="p">()</span>
<span class="linenos">42</span><span class="w">        </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">dir_entry</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">43</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">name_with_ext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dir_entry</span><span class="p">.</span><span class="n">unwrap</span><span class="p">().</span><span class="n">file_name</span><span class="p">().</span><span class="n">into_string</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span>
<span class="linenos">44</span><span class="w">            </span><span class="n">name_with_ext</span><span class="p">.</span><span class="n">drain</span><span class="p">(</span><span class="n">name_with_ext</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="sc">&#39;.&#39;</span><span class="p">).</span><span class="n">unwrap</span><span class="p">()</span><span class="o">..</span><span class="n">name_with_ext</span><span class="p">.</span><span class="n">len</span><span class="p">());</span>
<span class="linenos">45</span><span class="w">            </span><span class="n">name_with_ext</span>
<span class="linenos">46</span><span class="w">        </span><span class="p">})</span>
<span class="linenos">47</span><span class="w">        </span><span class="p">.</span><span class="n">collect</span><span class="p">();</span>
<span class="linenos">48</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">app</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">apps</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">49</span><span class="w">        </span><span class="c1">// load app data from host file system</span>
<span class="linenos">50</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">host_file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="fm">format!</span><span class="p">(</span><span class="s">&quot;{}{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">target_path</span><span class="p">,</span><span class="w"> </span><span class="n">app</span><span class="p">)).</span><span class="n">unwrap</span><span class="p">();</span>
<span class="linenos">51</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">all_data</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">new</span><span class="p">();</span>
<span class="linenos">52</span><span class="w">        </span><span class="n">host_file</span><span class="p">.</span><span class="n">read_to_end</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">all_data</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>
<span class="linenos">53</span><span class="w">        </span><span class="c1">// create a file in easy-fs</span>
<span class="linenos">54</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">inode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">root_inode</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="n">app</span><span class="p">.</span><span class="n">as_str</span><span class="p">()).</span><span class="n">unwrap</span><span class="p">();</span>
<span class="linenos">55</span><span class="w">        </span><span class="c1">// write data to easy-fs</span>
<span class="linenos">56</span><span class="w">        </span><span class="n">inode</span><span class="p">.</span><span class="n">write_at</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">all_data</span><span class="p">.</span><span class="n">as_slice</span><span class="p">());</span>
<span class="linenos">57</span><span class="w">    </span><span class="p">}</span>
<span class="linenos">58</span><span class="w">    </span><span class="c1">// list apps</span>
<span class="linenos">59</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">app</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">root_inode</span><span class="p">.</span><span class="n">ls</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">60</span><span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">app</span><span class="p">);</span>
<span class="linenos">61</span><span class="w">    </span><span class="p">}</span>
<span class="linenos">62</span><span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span>
<span class="linenos">63</span><span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>为了实现 <code class="docutils literal notranslate"><span class="pre">easy-fs-fuse</span></code> 和 <code class="docutils literal notranslate"><span class="pre">os/user</span></code> 的解耦，第 6~21 行使用 <code class="docutils literal notranslate"><span class="pre">clap</span></code> crate 进行命令行参数解析，需要通过 <code class="docutils literal notranslate"><span class="pre">-s</span></code> 和 <code class="docutils literal notranslate"><span class="pre">-t</span></code> 分别指定应用的源代码目录和保存应用 ELF 的目录，而不是在 <code class="docutils literal notranslate"><span class="pre">easy-fs-fuse</span></code> 中硬编码。如果解析成功的话它们会分别被保存在变量 <code class="docutils literal notranslate"><span class="pre">src_path</span></code> 和 <code class="docutils literal notranslate"><span class="pre">target_path</span></code> 中。</p></li>
<li><p>第 23~38 行依次完成：创建 4MiB 的 easy-fs 镜像文件、进行 easy-fs 初始化、获取根目录 inode 。</p></li>
<li><p>第 39 行获取源码目录中的每个应用的源代码文件并去掉后缀名，收集到向量 <code class="docutils literal notranslate"><span class="pre">apps</span></code> 中。</p></li>
<li><p>第 48 行开始，枚举 <code class="docutils literal notranslate"><span class="pre">apps</span></code> 中的每个应用，从放置应用执行程序的目录中找到对应应用的 ELF 文件（这是一个 Linux 上的文件），并将数据读入内存。接着需要在 easy-fs 中创建一个同名文件并将 ELF 数据写入到这个文件中。这个过程相当于将 Linux 上的文件系统中的一个文件复制到我们的 easy-fs 中。</p></li>
</ul>
<p>尽管没有进行任何同步写回磁盘的操作，我们也不用担心块缓存中的修改没有写回磁盘。因为在 <code class="docutils literal notranslate"><span class="pre">easy-fs-fuse</span></code> 这个应用正常退出的过程中，块缓存因生命周期结束会被回收，届时如果块缓存的 <code class="docutils literal notranslate"><span class="pre">modified</span></code> 标志为 true ，就会将其修改写回磁盘。</p>
</div>
</div>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="3using-easy-fs-in-kernel.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">在内核中接入 easy-fs</div>
              </div>
              <svg><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="1fs-interface.html">
              <svg><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">文件系统接口</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2020-2022, Yu Chen, Yifan Wu
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            <div class="icons">
              
            </div>
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            目录
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">简易文件系统 easy-fs</a><ul>
<li><a class="reference internal" href="#id1">本节导读</a></li>
<li><a class="reference internal" href="#id2">松耦合模块化设计思路</a></li>
<li><a class="reference internal" href="#id3">块设备接口层</a></li>
<li><a class="reference internal" href="#id4">块缓存层</a><ul>
<li><a class="reference internal" href="#id5">块缓存</a></li>
<li><a class="reference internal" href="#id6">块缓存全局管理器</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id7">磁盘布局及磁盘上数据结构</a><ul>
<li><a class="reference internal" href="#id8">easy-fs 磁盘布局概述</a></li>
<li><a class="reference internal" href="#id9">easy-fs 超级块</a></li>
<li><a class="reference internal" href="#id10">位图</a></li>
<li><a class="reference internal" href="#id11">磁盘上索引节点</a></li>
<li><a class="reference internal" href="#id12">数据块与目录项</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id13">磁盘块管理器</a></li>
<li><a class="reference internal" href="#id14">索引节点</a><ul>
<li><a class="reference internal" href="#inode">获取根目录的 inode</a></li>
<li><a class="reference internal" href="#id15">文件索引</a></li>
<li><a class="reference internal" href="#id16">文件列举</a></li>
<li><a class="reference internal" href="#id17">文件创建</a></li>
<li><a class="reference internal" href="#id18">文件清空</a></li>
<li><a class="reference internal" href="#id19">文件读写</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id20">在用户态测试 easy-fs 的功能</a><ul>
<li><a class="reference internal" href="#rust">在Rust应用开发环境中模拟块设备</a></li>
<li><a class="reference internal" href="#id21">打开块设备</a></li>
<li><a class="reference internal" href="#id22">从块设备上打开文件系统</a></li>
<li><a class="reference internal" href="#id23">获取根目录的 Inode</a></li>
<li><a class="reference internal" href="#id24">进行各种文件操作</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id25">将应用打包为 easy-fs 镜像</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/scripts/furo.js"></script>
    <script kind="utterances">

    var commentsRunWhenDOMLoaded = cb => {
    if (document.readyState != 'loading') {
        cb()
    } else if (document.addEventListener) {
        document.addEventListener('DOMContentLoaded', cb)
    } else {
        document.attachEvent('onreadystatechange', function() {
        if (document.readyState == 'complete') cb()
        })
    }
}

var addUtterances = () => {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src = "https://utteranc.es/client.js";
    script.async = "async";

    script.setAttribute("repo", "rcore-os/rCore-Tutorial-Book-v3");
    script.setAttribute("issue-term", "pathname");
    script.setAttribute("theme", "github-light");
    script.setAttribute("label", "comments");
    script.setAttribute("crossorigin", "anonymous");

    sections = document.querySelectorAll("div.section");
    if (sections !== null) {
        section = sections[sections.length-1];
        section.appendChild(script);
    }
}
commentsRunWhenDOMLoaded(addUtterances);
</script>
    <script src="../_static/translations.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://unpkg.com/mermaid@9.3.0/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({startOnLoad:true});</script>
    <script src="../_static/mermaid.js"></script>
    </body>
</html>