

<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>内核第一条指令（实践篇） &mdash; rCore-Tutorial-Book-v3 3.6.0-alpha.1 文档</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/my_style.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script kind="utterances">

    var commentsRunWhenDOMLoaded = cb => {
    if (document.readyState != 'loading') {
        cb()
    } else if (document.addEventListener) {
        document.addEventListener('DOMContentLoaded', cb)
    } else {
        document.attachEvent('onreadystatechange', function() {
        if (document.readyState == 'complete') cb()
        })
    }
}

var addUtterances = () => {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src = "https://utteranc.es/client.js";
    script.async = "async";

    script.setAttribute("repo", "rcore-os/rCore-Tutorial-Book-v3");
    script.setAttribute("issue-term", "pathname");
    script.setAttribute("theme", "github-light");
    script.setAttribute("label", "comments");
    script.setAttribute("crossorigin", "anonymous");

    sections = document.querySelectorAll("div.section");
    if (sections !== null) {
        section = sections[sections.length-1];
        section.appendChild(script);
    }
}
commentsRunWhenDOMLoaded(addUtterances);
</script>
        <script src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="为内核支持函数调用" href="5support-func-call.html" />
    <link rel="prev" title="内核第一条指令（原理篇）" href="3first-instruction-in-kernel1.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> rCore-Tutorial-Book-v3
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="在文档中搜索" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">Part1 - Just do it!</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../chapter0/index.html">第零章：操作系统概述</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">第一章：应用程序与基本执行环境</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="0intro.html">引言</a></li>
<li class="toctree-l2"><a class="reference internal" href="1app-ee-platform.html">应用程序执行环境与平台支持</a></li>
<li class="toctree-l2"><a class="reference internal" href="2remove-std.html">移除标准库依赖</a></li>
<li class="toctree-l2"><a class="reference internal" href="3first-instruction-in-kernel1.html">内核第一条指令（原理篇）</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">内核第一条指令（实践篇）</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id2">本节导读</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">编写内核第一条指令</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">调整内核的内存布局</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id5">手动加载内核可执行文件</a></li>
<li class="toctree-l3"><a class="reference internal" href="#gdb">基于 GDB 验证启动流程</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="5support-func-call.html">为内核支持函数调用</a></li>
<li class="toctree-l2"><a class="reference internal" href="6print-and-shutdown-based-on-sbi.html">基于 SBI 服务完成输出和关机</a></li>
<li class="toctree-l2"><a class="reference internal" href="7exercise.html">练习</a></li>
<li class="toctree-l2"><a class="reference internal" href="8answer.html">练习参考答案</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapter2/index.html">第二章：批处理系统</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter3/index.html">第三章：多道程序与分时多任务</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter4/index.html">第四章：地址空间</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter5/index.html">第五章：进程</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter6/index.html">第六章：文件系统</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter7/index.html">第七章：进程间通信与 I/O 重定向</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter8/index.html">第八章：并发</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter9/index.html">第九章：I/O设备管理</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">附录</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../final-lab.html">综合练习</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendix-a/index.html">附录 A：Rust 系统编程入门</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendix-b/index.html">附录 B：常见工具的使用方法</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendix-c/index.html">附录 C：深入机器模式：RustSBI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendix-d/index.html">附录 D：RISC-V相关信息</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendix-e/index.html">附录 E：操作系统进一步介绍</a></li>
<li class="toctree-l1"><a class="reference internal" href="../terminology.html">术语中英文对照表</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">开发注记</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../setup-sphinx.html">修改和构建本项目</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rest-example.html">reStructuredText 基本语法</a></li>
<li class="toctree-l1"><a class="reference internal" href="../log.html">更新日志</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">rCore-Tutorial-Book-v3</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">第一章：应用程序与基本执行环境</a> &raquo;</li>
        
      <li>内核第一条指令（实践篇）</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/chapter1/4first-instruction-in-kernel2.rst.txt" rel="nofollow"> 查看页面源码</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="id1">
<h1>内核第一条指令（实践篇）<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<div class="toctree-wrapper compound">
</div>
<div class="section" id="id2">
<h2>本节导读<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>承接上一节，本节我们将实践在 Qemu 上执行内核第一条指令。首先我们编写内核第一条指令并嵌入到我们的内核项目中，接着指定内核的内存布局使得我们的内核可以正确对接到 Qemu 中。由于 Qemu 的文件加载功能过于简单，它不支持完整的可执行文件，因此我们从内核可执行文件中剥离多余的元数据得到内核镜像并提供给 Qemu 。最后，我们使用 GDB 来跟踪 Qemu 的整个启动流程并验证内核的第一条指令被正确执行。</p>
<p>提示：在进入本节之前请参考 <a class="reference internal" href="../chapter0/5setup-devel-env.html"><span class="doc">实验环境配置</span></a> 安装配置 Rust 相关软件包和 GDB 调试工具。</p>
</div>
<div class="section" id="id3">
<h2>编写内核第一条指令<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<p>首先，我们需要编写进入内核后的第一条指令，这样更方便我们验证我们的内核镜像是否正确对接到 Qemu 上。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span> <span class="c1"># os/src/entry.asm</span>
<span class="linenos">2</span>     <span class="o">.</span><span class="n">section</span> <span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="n">entry</span>
<span class="linenos">3</span>     <span class="o">.</span><span class="n">globl</span> <span class="n">_start</span>
<span class="linenos">4</span> <span class="n">_start</span><span class="p">:</span>
<span class="linenos">5</span>     <span class="n">li</span> <span class="n">x1</span><span class="p">,</span> <span class="mi">100</span>
</pre></div>
</div>
<p>实际的指令位于第 5 行，也即 <code class="docutils literal notranslate"><span class="pre">li</span> <span class="pre">x1,</span> <span class="pre">100</span></code> 。 <code class="docutils literal notranslate"><span class="pre">li</span></code> 是 Load Immediate 的缩写，也即将一个立即数加载到某个寄存器，因此这条指令可以看做将寄存器 <code class="docutils literal notranslate"><span class="pre">x1</span></code> 赋值为 <code class="docutils literal notranslate"><span class="pre">100</span></code> 。第 4 行我们声明了一个符号 <code class="docutils literal notranslate"><span class="pre">_start</span></code> ，该符号指向紧跟在符号后面的内容——也就是位于第 5 行的指令，因此符号 <code class="docutils literal notranslate"><span class="pre">_start</span></code> 的地址即为第 5 行的指令所在的地址。第 3 行我们告知编译器 <code class="docutils literal notranslate"><span class="pre">_start</span></code> 是一个全局符号，因此可以被其他目标文件使用。第 2 行表明我们希望将第 2 行后面的内容全部放到一个名为 <code class="docutils literal notranslate"><span class="pre">.text.entry</span></code> 的段中。一般情况下，所有的代码都被放到一个名为 <code class="docutils literal notranslate"><span class="pre">.text</span></code> 的代码段中，这里我们将其命名为 <code class="docutils literal notranslate"><span class="pre">.text.entry</span></code> 从而区别于其他 <code class="docutils literal notranslate"><span class="pre">.text</span></code> 的目的在于我们想要确保该段被放置在相比任何其他代码段更低的地址上。这样，作为内核的入口点，这段指令才能被最先执行。</p>
<p>接着，我们在 <code class="docutils literal notranslate"><span class="pre">main.rs</span></code> 中嵌入这段汇编代码，这样 Rust 编译器才能够注意到它，不然编译器会认为它是一个与项目无关的文件：</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="c1">// os/src/main.rs</span>
<span class="linenos">2</span><span class="cp">#![no_std]</span><span class="w"></span>
<span class="linenos">3</span><span class="cp">#![no_main]</span><span class="w"></span>
<span class="linenos">4</span>
<span class="linenos">5</span><span class="k">mod</span> <span class="nn">lang_item</span><span class="p">;</span><span class="w"></span>
<span class="linenos">6</span>
<span class="linenos">7</span><span class="k">use</span><span class="w"> </span><span class="n">core</span>::<span class="n">arch</span>::<span class="n">global_asm</span><span class="p">;</span><span class="w"></span>
<span class="hll"><span class="linenos">8</span><span class="fm">global_asm!</span><span class="p">(</span><span class="fm">include_str!</span><span class="p">(</span><span class="s">&quot;entry.asm&quot;</span><span class="p">));</span><span class="w"></span>
</span></pre></div>
</div>
<p>第 8 行，我们通过 <code class="docutils literal notranslate"><span class="pre">include_str!</span></code> 宏将同目录下的汇编代码 <code class="docutils literal notranslate"><span class="pre">entry.asm</span></code> 转化为字符串并通过 <code class="docutils literal notranslate"><span class="pre">global_asm!</span></code> 宏嵌入到代码中。可以看到，在经历了长时间的迭代之后， <code class="docutils literal notranslate"><span class="pre">global_asm!</span></code> 宏已被加入到 Rust 核心库 core 中。</p>
</div>
<div class="section" id="id4">
<h2>调整内核的内存布局<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<p id="term-linker-script">由于链接器默认的内存布局并不能符合我们的要求，实现与 Qemu 的正确对接，我们可以通过 <strong>链接脚本</strong> (Linker Script) 调整链接器的行为，使得最终生成的可执行文件的内存布局符合我们的预期。我们修改 Cargo 的配置文件来使用我们自己的链接脚本 <code class="docutils literal notranslate"><span class="pre">os/src/linker.ld</span></code> 而非使用默认的内存布局：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span> <span class="o">//</span> <span class="n">os</span><span class="o">/.</span><span class="n">cargo</span><span class="o">/</span><span class="n">config</span>
<span class="linenos">2</span> <span class="p">[</span><span class="n">build</span><span class="p">]</span>
<span class="linenos">3</span> <span class="n">target</span> <span class="o">=</span> <span class="s2">&quot;riscv64gc-unknown-none-elf&quot;</span>
<span class="linenos">4</span>
<span class="hll"><span class="linenos">5</span> <span class="p">[</span><span class="n">target</span><span class="o">.</span><span class="n">riscv64gc</span><span class="o">-</span><span class="n">unknown</span><span class="o">-</span><span class="n">none</span><span class="o">-</span><span class="n">elf</span><span class="p">]</span>
</span><span class="hll"><span class="linenos">6</span> <span class="n">rustflags</span> <span class="o">=</span> <span class="p">[</span>
</span><span class="hll"><span class="linenos">7</span>     <span class="s2">&quot;-Clink-arg=-Tsrc/linker.ld&quot;</span><span class="p">,</span> <span class="s2">&quot;-Cforce-frame-pointers=yes&quot;</span>
</span><span class="hll"><span class="linenos">8</span> <span class="p">]</span>
</span></pre></div>
</div>
<p>链接脚本 <code class="docutils literal notranslate"><span class="pre">os/src/linker.ld</span></code> 如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="n">OUTPUT_ARCH</span><span class="p">(</span><span class="n">riscv</span><span class="p">)</span>
<span class="linenos"> 2</span><span class="n">ENTRY</span><span class="p">(</span><span class="n">_start</span><span class="p">)</span>
<span class="linenos"> 3</span><span class="n">BASE_ADDRESS</span> <span class="o">=</span> <span class="mh">0x80200000</span><span class="p">;</span>
<span class="linenos"> 4</span>
<span class="linenos"> 5</span><span class="n">SECTIONS</span>
<span class="linenos"> 6</span><span class="p">{</span>
<span class="linenos"> 7</span>    <span class="o">.</span> <span class="o">=</span> <span class="n">BASE_ADDRESS</span><span class="p">;</span>
<span class="linenos"> 8</span>    <span class="n">skernel</span> <span class="o">=</span> <span class="o">.</span><span class="p">;</span>
<span class="linenos"> 9</span>
<span class="linenos">10</span>    <span class="n">stext</span> <span class="o">=</span> <span class="o">.</span><span class="p">;</span>
<span class="linenos">11</span>    <span class="o">.</span><span class="n">text</span> <span class="p">:</span> <span class="p">{</span>
<span class="hll"><span class="linenos">12</span>        <span class="o">*</span><span class="p">(</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="n">entry</span><span class="p">)</span>
</span><span class="linenos">13</span>        <span class="o">*</span><span class="p">(</span><span class="o">.</span><span class="n">text</span> <span class="o">.</span><span class="n">text</span><span class="o">.*</span><span class="p">)</span>
<span class="linenos">14</span>    <span class="p">}</span>
<span class="linenos">15</span>
<span class="linenos">16</span>    <span class="o">.</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="mi">4</span><span class="n">K</span><span class="p">);</span>
<span class="linenos">17</span>    <span class="n">etext</span> <span class="o">=</span> <span class="o">.</span><span class="p">;</span>
<span class="linenos">18</span>    <span class="n">srodata</span> <span class="o">=</span> <span class="o">.</span><span class="p">;</span>
<span class="linenos">19</span>    <span class="o">.</span><span class="n">rodata</span> <span class="p">:</span> <span class="p">{</span>
<span class="linenos">20</span>        <span class="o">*</span><span class="p">(</span><span class="o">.</span><span class="n">rodata</span> <span class="o">.</span><span class="n">rodata</span><span class="o">.*</span><span class="p">)</span>
<span class="linenos">21</span>        <span class="o">*</span><span class="p">(</span><span class="o">.</span><span class="n">srodata</span> <span class="o">.</span><span class="n">srodata</span><span class="o">.*</span><span class="p">)</span>
<span class="linenos">22</span>    <span class="p">}</span>
<span class="linenos">23</span>
<span class="linenos">24</span>    <span class="o">.</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="mi">4</span><span class="n">K</span><span class="p">);</span>
<span class="linenos">25</span>    <span class="n">erodata</span> <span class="o">=</span> <span class="o">.</span><span class="p">;</span>
<span class="linenos">26</span>    <span class="n">sdata</span> <span class="o">=</span> <span class="o">.</span><span class="p">;</span>
<span class="linenos">27</span>    <span class="o">.</span><span class="n">data</span> <span class="p">:</span> <span class="p">{</span>
<span class="linenos">28</span>        <span class="o">*</span><span class="p">(</span><span class="o">.</span><span class="n">data</span> <span class="o">.</span><span class="n">data</span><span class="o">.*</span><span class="p">)</span>
<span class="linenos">29</span>        <span class="o">*</span><span class="p">(</span><span class="o">.</span><span class="n">sdata</span> <span class="o">.</span><span class="n">sdata</span><span class="o">.*</span><span class="p">)</span>
<span class="linenos">30</span>    <span class="p">}</span>
<span class="linenos">31</span>
<span class="linenos">32</span>    <span class="o">.</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="mi">4</span><span class="n">K</span><span class="p">);</span>
<span class="linenos">33</span>    <span class="n">edata</span> <span class="o">=</span> <span class="o">.</span><span class="p">;</span>
<span class="linenos">34</span>    <span class="o">.</span><span class="n">bss</span> <span class="p">:</span> <span class="p">{</span>
<span class="linenos">35</span>        <span class="o">*</span><span class="p">(</span><span class="o">.</span><span class="n">bss</span><span class="o">.</span><span class="n">stack</span><span class="p">)</span>
<span class="linenos">36</span>        <span class="n">sbss</span> <span class="o">=</span> <span class="o">.</span><span class="p">;</span>
<span class="linenos">37</span>        <span class="o">*</span><span class="p">(</span><span class="o">.</span><span class="n">bss</span> <span class="o">.</span><span class="n">bss</span><span class="o">.*</span><span class="p">)</span>
<span class="linenos">38</span>        <span class="o">*</span><span class="p">(</span><span class="o">.</span><span class="n">sbss</span> <span class="o">.</span><span class="n">sbss</span><span class="o">.*</span><span class="p">)</span>
<span class="linenos">39</span>    <span class="p">}</span>
<span class="linenos">40</span>
<span class="linenos">41</span>    <span class="o">.</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="mi">4</span><span class="n">K</span><span class="p">);</span>
<span class="linenos">42</span>    <span class="n">ebss</span> <span class="o">=</span> <span class="o">.</span><span class="p">;</span>
<span class="linenos">43</span>    <span class="n">ekernel</span> <span class="o">=</span> <span class="o">.</span><span class="p">;</span>
<span class="linenos">44</span>
<span class="linenos">45</span>    <span class="o">/</span><span class="n">DISCARD</span><span class="o">/</span> <span class="p">:</span> <span class="p">{</span>
<span class="linenos">46</span>        <span class="o">*</span><span class="p">(</span><span class="o">.</span><span class="n">eh_frame</span><span class="p">)</span>
<span class="linenos">47</span>    <span class="p">}</span>
<span class="linenos">48</span><span class="p">}</span>
</pre></div>
</div>
<p>第 1 行我们设置了目标平台为 riscv ；第 2 行我们设置了整个程序的入口点为之前定义的全局符号 <code class="docutils literal notranslate"><span class="pre">_start</span></code>；</p>
<p>第 3 行定义了一个常量 <code class="docutils literal notranslate"><span class="pre">BASE_ADDRESS</span></code> 为 <code class="docutils literal notranslate"><span class="pre">0x80200000</span></code> ，也就是我们之前提到的初始化代码被放置的地址；</p>
<p>从第 5 行开始体现了链接过程中对输入的目标文件的段的合并。其中 <code class="docutils literal notranslate"><span class="pre">.</span></code> 表示当前地址，也就是链接器会从它指向的位置开始往下放置从输入的目标文件中收集来的段。我们可以对 <code class="docutils literal notranslate"><span class="pre">.</span></code> 进行赋值来调整接下来的段放在哪里，也可以创建一些全局符号赋值为 <code class="docutils literal notranslate"><span class="pre">.</span></code> 从而记录这一时刻的位置。我们还能够看到这样的格式：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">.</span><span class="n">rodata</span> <span class="p">:</span> <span class="p">{</span>
    <span class="o">*</span><span class="p">(</span><span class="o">.</span><span class="n">rodata</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>冒号前面表示最终生成的可执行文件的一个段的名字，花括号内按照放置顺序描述将所有输入目标文件的哪些段放在这个段中，每一行格式为 <code class="docutils literal notranslate"><span class="pre">&lt;ObjectFile&gt;(SectionName)</span></code>，表示目标文件 <code class="docutils literal notranslate"><span class="pre">ObjectFile</span></code> 的名为 <code class="docutils literal notranslate"><span class="pre">SectionName</span></code> 的段需要被放进去。我们也可以使用通配符来书写 <code class="docutils literal notranslate"><span class="pre">&lt;ObjectFile&gt;</span></code> 和 <code class="docutils literal notranslate"><span class="pre">&lt;SectionName&gt;</span></code> 分别表示可能的输入目标文件和段名。因此，最终的合并结果是，在最终可执行文件中各个常见的段 <code class="docutils literal notranslate"><span class="pre">.text,</span> <span class="pre">.rodata</span> <span class="pre">.data,</span> <span class="pre">.bss</span></code> 从低地址到高地址按顺序放置，每个段里面都包括了所有输入目标文件的同名段，且每个段都有两个全局符号给出了它的开始和结束地址（比如 <code class="docutils literal notranslate"><span class="pre">.text</span></code> 段的开始和结束地址分别是 <code class="docutils literal notranslate"><span class="pre">stext</span></code> 和 <code class="docutils literal notranslate"><span class="pre">etext</span></code> ）。</p>
<p>第 12 行我们将包含内核第一条指令的 <code class="docutils literal notranslate"><span class="pre">.text.entry</span></code> 段放在最终的 <code class="docutils literal notranslate"><span class="pre">.text</span></code> 段的最开头，同时注意到在最终内存布局中代码段 <code class="docutils literal notranslate"><span class="pre">.text</span></code> 又是先于任何其他段的。因为所有的段都从 <code class="docutils literal notranslate"><span class="pre">BASE_ADDRESS</span></code> 也即 <code class="docutils literal notranslate"><span class="pre">0x80200000</span></code> 开始放置，这就能够保证内核的第一条指令正好放在 <code class="docutils literal notranslate"><span class="pre">0x80200000</span></code> 从而能够正确对接到 Qemu 上。</p>
<p>此后我们便可以生成内核可执行文件，切换到 <code class="docutils literal notranslate"><span class="pre">os</span></code> 目录下并进行以下操作：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>cargo build --release
<span class="go">Finished release [optimized] target(s) in 0.10s</span>
<span class="gp">$ </span>file target/riscv64gc-unknown-none-elf/release/os
<span class="go">target/riscv64gc-unknown-none-elf/release/os: ELF 64-bit LSB executable, UCB RISC-V, version 1 (SYSV), statically linked, not stripped</span>
</pre></div>
</div>
<p>我们以 <code class="docutils literal notranslate"><span class="pre">release</span></code> 模式生成了内核可执行文件，它的位置在 <code class="docutils literal notranslate"><span class="pre">os/target/riscv64gc.../release/os</span></code> 。接着我们通过 <code class="docutils literal notranslate"><span class="pre">file</span></code> 工具查看它的属性，可以看到它是一个运行在 64 位 RISC-V 架构计算机上的可执行文件，它是静态链接得到的。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p><strong>思考： 0x80200000 可否改为其他地址？</strong></p>
<p>首先需要区分绝对地址和相对地址。在对编译器进行某些设置的情况下，在访问变量或函数时，可以通过它们所在地址与当前某个寄存器（如 PC）的相对地址而非它们位于的绝对地址来访问这些变量或函数。比如，在一个起始地址（即上面提到的 <code class="docutils literal notranslate"><span class="pre">BASE_ADDRESS</span></code> ）固定为 <code class="docutils literal notranslate"><span class="pre">0x80200000</span></code> 的内存布局中，某个函数入口位于 <code class="docutils literal notranslate"><span class="pre">0x80201111</span></code> 处，那么我们可以使用其绝对地址 <code class="docutils literal notranslate"><span class="pre">0x80201111</span></code> 来访问它。但是，如果一条位于 <code class="docutils literal notranslate"><span class="pre">0x80200111</span></code> 指令会调用该函数，那么这条指令也不一定要用到绝对地址 <code class="docutils literal notranslate"><span class="pre">0x80201111</span></code> ，而是用函数入口地址相对于当前指令地址 <code class="docutils literal notranslate"><span class="pre">0x80200111</span></code> 的相对地址 <code class="docutils literal notranslate"><span class="pre">0x1000</span></code> （计算方式为函数入口地址与当前指令地址之差值）来找到并调用该函数。</p>
<p>如果一个程序全程都使用相对地址而不依赖任何绝对地址，那么只要保持好各段之间的相对位置不发生变化，将程序整体加载到内存中的任意位置程序均可正常运行。在这种情况下， <code class="docutils literal notranslate"><span class="pre">BASE_ADDRESS</span></code> 可以为任意值，我们可以将程序在内存中随意平移。这种程序被称为 <strong>位置无关可执行文件（PIE，Position-independent Executable）</strong> 。相对的，如果程序依赖绝对地址，那么它一定有一个确定的内存布局，而且该程序必须被加载到与其内存布局一致的位置才能正常运行。由于我们的内核并不是位置无关的，所以我们必须将内存布局的起始地址设置为 <code class="docutils literal notranslate"><span class="pre">0x80200000</span></code> ，与之匹配我们也必须将内核加载到这一地址。</p>
</div>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p><strong>静态链接与动态链接</strong></p>
<p>静态链接是指程序在编译时就将所有用到的函数库的目标文件链接到可执行文件中，这样会导致可执行文件容量较大，占用硬盘空间；而动态链接是指程序在编译时仅在可执行文件中记录用到哪些函数库和在这些函数库中用到了哪些符号，在操作系统执行该程序准备将可执行文件加载到内存时，操作系统会检查这些被记录的信息，将用到的函数库的代码和数据和程序一并加载到内存，并进行一些重定位工作。使用动态链接可以显著缩减可执行文件的容量，并使得程序不必在函数库更新后重新链接依然可用。</p>
<p>Qemu 显然不支持在加载时动态链接，因此我们的内核采用静态链接进行编译。</p>
</div>
</div>
<div class="section" id="id5">
<h2>手动加载内核可执行文件<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h2>
<p>上面得到的内核可执行文件完全符合我们对于内存布局的要求，但是我们不能将其直接提交给 Qemu ，因为它除了实际会被用到的代码和数据段之外还有一些多余的元数据，这些元数据无法被 Qemu 在加载文件时利用，且会使代码和数据段被加载到错误的位置。如下图所示：</p>
<div class="figure align-center" id="id6">
<img alt="../_images/load-into-qemu.png" src="../_images/load-into-qemu.png" />
<p class="caption"><span class="caption-text">丢弃元数据前后的内核可执行文件被加载到 Qemu 上的情形</span><a class="headerlink" href="#id6" title="永久链接至图片">¶</a></p>
</div>
<p>图中，红色的区域表示内核可执行文件中的元数据，深蓝色的区域表示各个段（包括代码段和数据段），而浅蓝色区域则表示内核被执行的第一条指令，它位于深蓝色区域的开头。图示的上半部分中，我们直接将内核可执行文件 <code class="docutils literal notranslate"><span class="pre">os</span></code> 加载到 Qemu 内存的 <code class="docutils literal notranslate"><span class="pre">0x80200000</span></code> 处，由于内核可执行文件的开头是一段元数据，这会导致 Qemu 内存 <code class="docutils literal notranslate"><span class="pre">0x80200000</span></code> 处无法找到内核第一条指令，也就意味着 RustSBI 无法正常将计算机控制权转交给内核。相反，图示的下半部分中，将元数据丢弃得到的内核镜像 <code class="docutils literal notranslate"><span class="pre">os.bin</span></code> 被加载到 Qemu 之后，则可以在 <code class="docutils literal notranslate"><span class="pre">0x80200000</span></code> 处正确找到内核第一条指令。如果想要深入了解这些元数据的内容，可以参考 <a class="reference internal" href="../appendix-b/index.html"><span class="doc">附录 B：常见工具的使用方法</span></a> 。</p>
<p id="content-binary-from-elf">使用如下命令可以丢弃内核可执行文件中的元数据得到内核镜像：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>rust-objcopy --strip-all target/riscv64gc-unknown-none-elf/release/os -O binary target/riscv64gc-unknown-none-elf/release/os.bin
</pre></div>
</div>
<p>我们可以使用 <code class="docutils literal notranslate"><span class="pre">stat</span></code> 工具来比较内核可执行文件和内核镜像的大小：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>stat target/riscv64gc-unknown-none-elf/release/os
<span class="go">File: target/riscv64gc-unknown-none-elf/release/os</span>
<span class="go">Size: 1016              Blocks: 8          IO Block: 4096   regular file</span>
<span class="go">...</span>
<span class="gp">$ </span>stat target/riscv64gc-unknown-none-elf/release/os.bin
<span class="go">File: target/riscv64gc-unknown-none-elf/release/os.bin</span>
<span class="go">Size: 4                 Blocks: 8          IO Block: 4096   regular file</span>
<span class="go">...</span>
</pre></div>
</div>
<p>可以看到，内核镜像的大小仅有 4 字节，这是因为它里面仅包含我们在 <code class="docutils literal notranslate"><span class="pre">entry.asm</span></code> 中编写的一条指令。一般情况下 RISC-V 架构的一条指令位宽即为 4 字节。而内核可执行文件由于包含了两部分元数据，其大小达到了 1016 字节。这些元数据能够帮助我们更加灵活地加载并使用可执行文件，比如在加载时完成一些重定位工作或者动态链接。不过由于 Qemu 的加载功能过于简单，我们只能将这些元数据丢弃再交给 Qemu 。从某种意义上可以理解为我们手动帮助 Qemu 完成了可执行文件的加载。</p>
</div>
<div class="section" id="gdb">
<h2>基于 GDB 验证启动流程<a class="headerlink" href="#gdb" title="永久链接至标题">¶</a></h2>
<p>在 <code class="docutils literal notranslate"><span class="pre">os</span></code> 目录下通过以下命令启动 Qemu 并加载 RustSBI 和内核镜像：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="gp">$ </span>qemu-system-riscv64 <span class="se">\</span>
<span class="linenos">2</span>    -machine virt <span class="se">\</span>
<span class="linenos">3</span>    -nographic <span class="se">\</span>
<span class="linenos">4</span>    -bios ../bootloader/rustsbi-qemu.bin <span class="se">\</span>
<span class="linenos">5</span>    -device loader,file<span class="o">=</span>target/riscv64gc-unknown-none-elf/release/os.bin,addr<span class="o">=</span>0x80200000 <span class="se">\</span>
<span class="linenos">6</span>    -s -S
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">-s</span></code> 可以使 Qemu 监听本地 TCP 端口 1234 等待 GDB 客户端连接，而 <code class="docutils literal notranslate"><span class="pre">-S</span></code> 可以使 Qemu 在收到 GDB 的请求后再开始运行。因此，Qemu 暂时没有任何输出。</p>
<p>打开另一个终端，启动一个 GDB 客户端连接到 Qemu ：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>riscv64-unknown-elf-gdb <span class="se">\</span>
    -ex <span class="s1">&#39;file target/riscv64gc-unknown-none-elf/release/os&#39;</span> <span class="se">\</span>
    -ex <span class="s1">&#39;set arch riscv:rv64&#39;</span> <span class="se">\</span>
    -ex <span class="s1">&#39;target remote localhost:1234&#39;</span>
<span class="go">[GDB output]</span>
<span class="go">0x0000000000001000 in ?? ()</span>
</pre></div>
</div>
<p>可以看到，正如我们在上一节提到的那样，Qemu 启动后 PC 被初始化为 <code class="docutils literal notranslate"><span class="pre">0x1000</span></code> 。我们可以检查一下 Qemu 的启动固件的内容：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span><span class="o">(</span>gdb<span class="o">)</span> x/10i <span class="nv">$pc</span>
<span class="go">=&gt; 0x1000:  auipc   t0,0x0</span>
<span class="go">0x1004:     addi    a1,t0,32</span>
<span class="go">0x1008:     csrr    a0,mhartid</span>
<span class="go">0x100c:     ld      t0,24(t0)</span>
<span class="go">0x1010:     jr      t0</span>
<span class="go">0x1014:     unimp</span>
<span class="go">0x1016:     unimp</span>
<span class="go">0x1018:     unimp</span>
<span class="go">0x101a:     0x8000</span>
<span class="go">0x101c:     unimp</span>
</pre></div>
</div>
<p>这里 <code class="docutils literal notranslate"><span class="pre">x/10i</span> <span class="pre">$pc</span></code> 的含义是从当前 PC 值的位置开始，在内存中反汇编 10 条指令。不过可以看到 Qemu 的固件仅包含 5 条指令，从 <code class="docutils literal notranslate"><span class="pre">0x1014</span></code> 开始都是数据，当数据为 0 的时候则会被反汇编为 <code class="docutils literal notranslate"><span class="pre">unimp</span></code> 指令。 <code class="docutils literal notranslate"><span class="pre">0x101a</span></code> 处的数据 <code class="docutils literal notranslate"><span class="pre">0x8000</span></code> 是能够跳转到 <code class="docutils literal notranslate"><span class="pre">0x80000000</span></code> 进入启动下一阶段的关键。有兴趣的读者可以自行探究位于 <code class="docutils literal notranslate"><span class="pre">0x1000</span></code> 和 <code class="docutils literal notranslate"><span class="pre">0x100c</span></code> 两条指令的含义。总之，在执行位于 <code class="docutils literal notranslate"><span class="pre">0x1010</span></code> 的指令之前，寄存器 <code class="docutils literal notranslate"><span class="pre">t0</span></code> 的值恰好为 <code class="docutils literal notranslate"><span class="pre">0x80000000</span></code> ，随后通过 <code class="docutils literal notranslate"><span class="pre">jr</span> <span class="pre">t0</span></code> 便可以跳转到该地址。我们可以通过单步调试来复盘这个过程：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span><span class="o">(</span>gdb<span class="o">)</span> si
<span class="go">0x0000000000001004 in ?? ()</span>
<span class="gp">$ </span><span class="o">(</span>gdb<span class="o">)</span> si
<span class="go">0x0000000000001008 in ?? ()</span>
<span class="gp">$ </span><span class="o">(</span>gdb<span class="o">)</span> si
<span class="go">0x000000000000100c in ?? ()</span>
<span class="gp">$ </span><span class="o">(</span>gdb<span class="o">)</span> si
<span class="go">0x0000000000001010 in ?? ()</span>
<span class="gp">$ </span><span class="o">(</span>gdb<span class="o">)</span> p/x <span class="nv">$t0</span>
<span class="gp">$</span><span class="nv">1</span> <span class="o">=</span> 0x80000000
<span class="gp">$ </span><span class="o">(</span>gdb<span class="o">)</span> si
<span class="go">0x0000000080000000 in ?? ()</span>
</pre></div>
</div>
<p>其中， <code class="docutils literal notranslate"><span class="pre">si</span></code> 可以让 Qemu 每次向下执行一条指令，之后屏幕会打印出待执行的下一条指令的地址。 <code class="docutils literal notranslate"><span class="pre">p/x</span> <span class="pre">$t0</span></code> 以 16 进制打印寄存器 <code class="docutils literal notranslate"><span class="pre">t0</span></code> 的值，注意当我们要打印寄存器的时候需要在寄存器的名字前面加上 <code class="docutils literal notranslate"><span class="pre">$</span></code> 。可以看到，当位于 <code class="docutils literal notranslate"><span class="pre">0x1010</span></code> 的指令执行完毕后，下一条待执行的指令位于 RustSBI 的入口，也即 <code class="docutils literal notranslate"><span class="pre">0x80000000</span></code> ，这意味着我们即将把控制权转交给 RustSBI 。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span><span class="o">(</span>gdb<span class="o">)</span> x/10i <span class="nv">$pc</span>
<span class="go">=&gt; 0x80000000:      auipc   sp,0x28</span>
<span class="go">0x80000004: mv      sp,sp</span>
<span class="go">0x80000008: lui     t0,0x4</span>
<span class="go">0x8000000a: addi    t1,a0,1</span>
<span class="go">0x8000000e: add     sp,sp,t0</span>
<span class="go">0x80000010: addi    t1,t1,-1</span>
<span class="go">0x80000012: bnez    t1,0x8000000e</span>
<span class="go">0x80000016: j       0x8001125a</span>
<span class="go">0x8000001a: unimp</span>
<span class="go">0x8000001c: addi    sp,sp,-48</span>
<span class="gp">$ </span><span class="o">(</span>gdb<span class="o">)</span> si
<span class="go">0x0000000080000004 in ?? ()</span>
<span class="gp">$ </span><span class="o">(</span>gdb<span class="o">)</span> si
<span class="go">0x0000000080000008 in ?? ()</span>
<span class="gp">$ </span><span class="o">(</span>gdb<span class="o">)</span> si
<span class="go">0x000000008000000a in ?? ()</span>
<span class="gp">$ </span><span class="o">(</span>gdb<span class="o">)</span> si
<span class="go">0x000000008000000e in ?? ()</span>
</pre></div>
</div>
<p>我们可以用同样的方式反汇编 RustSBI 最初的几条指令并单步调试。不过由于 RustSBI 超出了本书的范围，我们这里并不打算进行深入。接下来我们检查控制权能否被移交给我们的内核：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span><span class="o">(</span>gdb<span class="o">)</span> b *0x80200000
<span class="go">Breakpoint 1 at 0x80200000</span>
<span class="gp">$ </span><span class="o">(</span>gdb<span class="o">)</span> c
<span class="go">Continuing.</span>

<span class="go">Breakpoint 1, 0x0000000080200000 in ?? ()</span>
</pre></div>
</div>
<p>我们在内核的入口点，也即地址 <code class="docutils literal notranslate"><span class="pre">0x80200000</span></code> 处打一个断点。需要注意，当需要在一个特定的地址打断点时，需要在地址前面加上 <code class="docutils literal notranslate"><span class="pre">*</span></code> 。接下来通过 <code class="docutils literal notranslate"><span class="pre">c</span></code> 命令（Continue 的缩写）让 Qemu 向下运行直到遇到一个断点。可以看到，我们成功停在了 <code class="docutils literal notranslate"><span class="pre">0x80200000</span></code> 处。随后，可以检查内核第一条指令是否被正确执行：</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span><span class="o">(</span>gdb<span class="o">)</span> x/5i <span class="nv">$pc</span>
<span class="go">=&gt; 0x80200000:      li      ra,100</span>
<span class="go">0x80200004: unimp</span>
<span class="go">0x80200006: unimp</span>
<span class="go">0x80200008: unimp</span>
<span class="go">0x8020000a: unimp</span>
<span class="gp">$ </span><span class="o">(</span>gdb<span class="o">)</span> si
<span class="go">0x0000000080200004 in ?? ()</span>
<span class="gp">$ </span><span class="o">(</span>gdb<span class="o">)</span> p/d <span class="nv">$x1</span>
<span class="gp">$</span><span class="nv">2</span> <span class="o">=</span> <span class="m">100</span>
<span class="gp">$ </span><span class="o">(</span>gdb<span class="o">)</span> p/x <span class="nv">$sp</span>
<span class="gp">$</span><span class="nv">3</span> <span class="o">=</span> 0x0
</pre></div>
</div>
<p>可以看到我们在 <code class="docutils literal notranslate"><span class="pre">entry.asm</span></code> 中编写的第一条指令可以在 <code class="docutils literal notranslate"><span class="pre">0x80200000</span></code> 处找到。这里 <code class="docutils literal notranslate"><span class="pre">ra</span></code> 是寄存器 <code class="docutils literal notranslate"><span class="pre">x1</span></code> 的别名， <code class="docutils literal notranslate"><span class="pre">p/d</span> <span class="pre">$x1</span></code> 可以以十进制打印寄存器 <code class="docutils literal notranslate"><span class="pre">x1</span></code> 的值，它的结果正确。最后，作为下一节的铺垫，我们可以检查此时栈指针 <code class="docutils literal notranslate"><span class="pre">sp</span></code> 的值，可以发现它目前是 0 。下一节我们将设置好栈使得内核代码可以正常进行函数调用，随后将控制权转交给 Rust 代码。</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="5support-func-call.html" class="btn btn-neutral float-right" title="为内核支持函数调用" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="3first-instruction-in-kernel1.html" class="btn btn-neutral float-left" title="内核第一条指令（原理篇）" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; 版权所有 2020-2022, Yu Chen, Yifan Wu.

    </p>
  </div>
    
    
    
    利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用了 
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    
    由 <a href="https://readthedocs.org">Read the Docs</a>开发. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>